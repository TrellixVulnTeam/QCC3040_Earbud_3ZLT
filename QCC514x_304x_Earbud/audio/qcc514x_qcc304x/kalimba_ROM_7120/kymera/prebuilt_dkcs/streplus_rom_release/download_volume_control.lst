
/home/svc-audio-dspsw/kymera_builds/builds/2021/kymera_2108031215/kalimba/kymera/tools/KCSMaker/out/7120/streplus_rom_release/download/debugbin/download_volume_control.elf:     file format elf32-littlekalimba

Disassembly of section .text_maxim:

84200000 <$_vol_ctrl_update_channel>:
.MODULE $M.vol_ctrl_update_channel;
    .MAXIM;
    .CODESEGMENT VOL_CTRL_UPD_CHAN_PM;

$_vol_ctrl_update_channel:
    pushm <r4,r5,r6,r7,r8,r9>;
84200000:	c0 0f 00 f1 	pushm <r4, r5, r6, r7, r8, r9>;
    pushm <I0,I1,I4,I5,M3,L0,L4,L5>;
84200004:	33 d8 01 f1 	pushm <I0, I1, I4, I5, M3, L0, L4, L5>;
    pushm <B0,B4,B5>;
84200008:	00 34 02 f1 	pushm <B0, B4, B5>;
    pushm <FP(=SP),r0,r1,r2,r3,rLink>;
8420000c:	3d 20 00 f1 	pushm <FP(=SP), r0, r1, r2, r3, rLink>;

   LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($vol_ctrl_update_channel.PATCH_ID_0, r7)

    /* Number of channels */
    r7 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.NUM_CHANNELS_FIELD];
84200010:	5c 00 92 d1 	r7 = M[r0 + 92];
    if LE jump vol_ctrl_apply_volume_abort;
84200014:	72 01 d0 dd 	if LE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_abort;

    // Enable saturate on add/sub
    r4 = M[$ARITHMETIC_MODE];
84200018:	14 e0 60 09 	r4 = Null + M[0xffffe014];
    push r4;
8420001c:	00 00 60 f3 	push r4;
    r4 = r4 OR $ADDSUB_SATURATE_ON_OVERFLOW_MASK;
84200020:	01 00 66 85 	r4 = r4 OR 0x1;
    M[$ARITHMETIC_MODE] = r4;
84200024:	14 e0 60 19 	M[0xffffe014] = r4 + Null;


    /* Update Channel for AUX stream priority.   */
    /* op_extra_data->aux_in_use  = 0; */
    M[r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_IN_USE_FIELD] = NULL;
84200028:	e8 02 02 d5 	M[r0 + 744] = Null;

8420002c <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_next>:
        {
            vol_ctrl_update_channel(op_extra_data,&op_extra_data->channels[i],op_extra_data->lpvols,&volume_tc);
        }
    */
vol_ctrl_update_channel_next:
    push r7;
8420002c:	00 00 90 f3 	push r7;
// r1: vol_ctrl_channel_t   *chan_ptr
// r2: vol_ctrl_gains_t     *volptr
// r3: vol_time_constants_t *lpvcs


    r4 = 1.0;
84200030:	ff 7f 00 fd 	r4 = Null + 2147483647;
84200034:	ff ff 60 01 
    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LIMITER_GAIN_LINEAR_FIELD]=r4;
84200038:	10 00 63 d5 	M[r1 + 16] = r4;
    // chan_idx
    r4 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHAN_IDX_FIELD];
8420003c:	00 00 63 d1 	r4 = M[r1 + 0];
    // target_vol (r5) = volptr->master_gain;
    r5 = M[r2 + $volume_control_cap.vol_ctrl_gains_struct.MASTER_GAIN_FIELD];
84200040:	00 00 74 d1 	r5 = M[r2 + 0];
    // channel_trim (r6) = volptr->channel_trims[chan_ptr->chan_idx];
    r6 = r4 * ADDR_PER_WORD (int);
84200044:	04 00 86 99 	r6 = r4 * 4 (int);
    r6 = r6 + $volume_control_cap.vol_ctrl_gains_struct.CHANNEL_TRIMS_FIELD;
84200048:	28 00 88 01 	r6 = r6 + 40;
    r6 = M[r2 + r6];
8420004c:	8f 00 84 d0 	r6 = M[r2 + r6];
    // chan_params (r7) = (vol_ctrl_chan_params_t*)&op_extra_data->parameters.OFFSET_CHAN1_AUX_ROUTE;
    // aux_routing (r9) = chan_params[chan_ptr->chan_idx].aux_routing;
    r8 = r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CHAN1_AUX_ROUTE_FIELD);
84200050:	f4 01 a2 01 	r8 = r0 + 500;
    r7 = r4 * ($volume_control_cap.vol_ctrl_chan_params_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
84200054:	14 00 96 99 	r7 = r4 * 20 (int);
    r7 = r7 + r8;
84200058:	00 00 9a 03 	r7 = r7 + r8;
    r9 = M[r7 + $volume_control_cap.vol_ctrl_chan_params_struct.AUX_ROUTING_FIELD];
8420005c:	00 00 b9 d1 	r9 = M[r7 + 0];
    // Pointer (I0) to Channel Aux prim_scale factors
    I0 = r7 + $volume_control_cap.vol_ctrl_chan_params_struct.PRIM_SCALE_FIELD;
84200060:	04 00 09 51 	I0 = r7 + 4;

    // Conditionally add in NDVC adjustment
    NULL = r9 AND $M.VOL_CTRL.CONSTANT.CHAN_NDVC_ENABLE_BIT;
84200064:	10 00 00 fd 	Null = r9 AND 0x100000;
84200068:	00 00 0b 81 
    if Z jump vol_ctrl_update_channel_no_ndvc;
8420006c:	05 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_no_ndvc;
        r8 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.SHARED_VOLUME_PTR_FIELD];
84200070:	8c 01 a2 d1 	r8 = M[r0 + 396];
        r8 = M[r8 + $volume_control_cap._shared_volume_struct.NDVC_NOISE_LEVEL_FIELD];
84200074:	00 00 aa d1 	r8 = M[r8 + 0];
	    /* NDVC is in 3dB steps */
        r8 = r8 * 180 (int);
84200078:	b4 00 aa 99 	r8 = r8 * 180 (int);
        r6 = r6 + r8;
8420007c:	00 00 8a 03 	r6 = r6 + r8;

84200080 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_no_ndvc>:
    vol_ctrl_update_channel_no_ndvc:

   /* Bypass Aux */
   NULL = M[r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_ACTIVE_FIELD];
84200080:	e0 02 02 d1 	Null = M[r0 + 736];
   if Z r9 = NULL;
84200084:	00 00 b0 00 	if EQ r9 = Null + Null;

    // channel_trim -= op_extra_data->post_gain;
    r8 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.POST_GAIN_FIELD];
84200088:	f4 00 a2 d1 	r8 = M[r0 + 244];
    r6 = r6 - r8;
8420008c:	00 00 8a 23 	r6 = r6 - r8;
    // target_vol = dB60toLinearQ5(target_vol+channel_trim);
    r0 = r6 + r5;
84200090:	7f 00 28 00 	r0 = r6 + r5;
    call $_dB60toLinearQ5;
84200094:	03 00 00 fd 	call (m) 0x37fbe;
84200098:	bf 7f f0 e1 

    // Update Channel Gain (r0 is target)
    r1 = M[FP + $vol_ctrl.cufp.chan_ptr];
8420009c:	08 00 38 f1 	r1 = M[FP + 0x8];
    r2 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHANNEL_GAIN_FIELD];
842000a0:	18 00 43 d1 	r2 = M[r1 + 24];

    r3 = M[FP + $vol_ctrl.cufp.tc_ptr];
842000a4:	10 00 58 f1 	r3 = M[FP + 0x10];
    r3 = M[r3 + $volume_control_cap.vol_time_constants_struct.VOL_TC_FIELD];
842000a8:	04 00 55 d1 	r3 = M[r3 + 4];

    r8 = r0 - r2;
842000ac:	4f 00 a2 20 	r8 = r0 - r2;
    if Z jump vol_ctrl_update_channel_no_vol_change;
842000b0:	09 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_no_vol_change;
        r8 = ABS r8;
842000b4:	4f 00 aa e4 	r8 = ABS r8;
        r3 = r2 * r3 (frac);
842000b8:	5f 00 54 94 	r3 = r2 * r3 (frac);
        r3 = r3 + $volume_and_limit.VOLUME_RAMP_OFFSET_CONST;
842000bc:	6e 34 55 01 	r3 = r3 + 13422;
        r3 = MIN r8;
842000c0:	5f 00 5a e4 	r3 = MIN r8;
        Null = r0 - r2;
842000c4:	4f 00 02 20 	Null = r0 - r2;
        if NEG r3 = -r3;
842000c8:	54 00 50 20 	if NEG r3 = Null - r3;
        r2 = r2 + r3;
842000cc:	00 00 45 03 	r2 = r2 + r3;
        M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHANNEL_GAIN_FIELD] = r2;
842000d0:	18 00 43 d5 	M[r1 + 24] = r2;

842000d4 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_no_vol_change>:
    vol_ctrl_update_channel_no_vol_change:

     r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
842000d4:	04 00 28 f1 	r0 = M[FP + 0x4];
     r0 = r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_CHANNEL_FIELD;
842000d8:	6c 00 22 01 	r0 = r0 + 108;

// r9=routing, r1=chan_ptr, I0=prim_scale, r0=aux_chan_ptr, r6=chan_trim, r4=chan_idx

    /* Check each aux in channel priority */
    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_MIX_GAIN_FIELD]  = NULL;
842000dc:	04 00 03 d5 	M[r1 + 4] = Null;
    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_BUFFER_FIELD]    = NULL;
842000e0:	20 00 03 d5 	M[r1 + 32] = Null;

842000e4 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_lp>:

    // while(aux_routing&VOL_CTRL_CONSTANT_AUX_PRIORITY_VALID_BIT)
vol_ctrl_update_channel_aux_prio_lp:
    NULL = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_VALID_BIT;
842000e4:	10 00 0b 81 	Null = r9 AND 0x10;
    if NZ jump vol_ctrl_update_channel_aux_prio_valid;
842000e8:	05 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_valid;
        // There is no AUX
        r2 = $volume_and_limit.OneQ5;
842000ec:	00 08 00 fd 	r2 = Null + 134217728;
842000f0:	00 00 40 01 
        M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD]      = r2;
842000f4:	08 00 43 d5 	M[r1 + 8] = r2;
        jump vol_ctrl_update_channel_aux_prio_done;
842000f8:	37 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_done;

842000fc <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_valid>:
vol_ctrl_update_channel_aux_prio_valid:
        // aux_idx =  aux_routing&VOL_CTRL_CONSTANT_AUX_PRIORITY_CHANNEL_MASK;
        r5 = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_CHANNEL_MASK;
842000fc:	07 00 7b 81 	r5 = r9 AND 0x7;
        // op_extra_data->aux_channel[aux_idx].state
        r8 = r5 * ($volume_control_cap.vol_ctrl_aux_channel_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
84200100:	10 00 a7 99 	r8 = r5 * 16 (int);
        r8 = r8 + r0,   r3=M[I0,M1];    // r3 = prim_scale
84200104:	00 51 a2 02 	r8 = r8 + r0, r3 = M[I0,M1];
        r7 = M[r8 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD];
84200108:	04 00 9a d1 	r7 = M[r8 + 4];
        if NZ jump vol_ctrl_update_channel_aux_prio_found;
8420010c:	03 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_found;
            // NO_AUX, Try Next entry
            r9 = r9 LSHIFT -$M.VOL_CTRL.CONSTANT.AUX_PRIORITY_NUM_BITS;
84200110:	fb 00 bb 8d 	r9 = r9 LSHIFT -5;
            jump vol_ctrl_update_channel_aux_prio_lp;
84200114:	f4 ff f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_lp;

84200118 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_found>:
vol_ctrl_update_channel_aux_prio_found:
        NULL = r7 - $volume_control_cap.AUX_STATE_IN_AUX;
84200118:	cf 00 09 e4 	Null = r7 - 2;
        if Z jump vol_ctrl_update_channel_aux_prio_in_aux;
8420011c:	16 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_in_aux;
    	    r2 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD];
84200120:	08 00 43 d1 	r2 = M[r1 + 8];

            NULL = r7 - $volume_control_cap.AUX_STATE_END_AUX;
84200124:	03 00 09 21 	Null = r7 - 3;
            if NZ jump vol_ctrl_update_channel_aux_prio_transition;
84200128:	0d 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_transition;
                // Leaving AUX mix,  see if a lower priority aux is pending
                r3 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD];
8420012c:	08 00 53 d1 	r3 = M[r1 + 8];

84200130 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_prev_lp>:
                vol_ctrl_update_channel_aux_prio_prev_lp:
                    r9 = r9 LSHIFT -$M.VOL_CTRL.CONSTANT.AUX_PRIORITY_NUM_BITS;
84200130:	fb 00 bb 8d 	r9 = r9 LSHIFT -5;
                    NULL = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_VALID_BIT;
84200134:	10 00 0b 81 	Null = r9 AND 0x10;
                    if Z jump vol_ctrl_update_channel_aux_prio_prev_none;
84200138:	07 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_prev_none;
                        r5 = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_CHANNEL_MASK;
8420013c:	07 00 7b 81 	r5 = r9 AND 0x7;
                        r5 = r5 * ($volume_control_cap.vol_ctrl_aux_channel_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
84200140:	10 00 77 99 	r5 = r5 * 16 (int);
                        r5 = r5 + r0,   r2=M[I0,M1];    // r3 = prim_scale
84200144:	00 41 72 02 	r5 = r5 + r0, r2 = M[I0,M1];
                        r7 = M[r5 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD];
84200148:	04 00 97 d1 	r7 = M[r5 + 4];
                        if Z jump vol_ctrl_update_channel_aux_prio_prev_lp;
8420014c:	f9 ff 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_prev_lp;
                        jump vol_ctrl_update_channel_aux_prio_transition;
84200150:	03 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_transition;

84200154 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_prev_none>:
                vol_ctrl_update_channel_aux_prio_prev_none:
                r2 = $volume_and_limit.OneQ5;
84200154:	00 08 00 fd 	r2 = Null + 134217728;
84200158:	00 00 40 01 

8420015c <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_transition>:

            vol_ctrl_update_channel_aux_prio_transition:
            // transition = op_extra_data->aux_channel[aux_idx].transition;
            r7 = M[r8 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD];
8420015c:	08 00 9a d1 	r7 = M[r8 + 8];
            // chan_ptr->prim_mix_gain = (MAXINT-transition)*Q5.xx + chan_params->prim_scale[chan_ptr->chan_idx]*transition;
            rMAC = r2;              // r2=1.0  Q5.xx
84200160:	0f 00 14 00 	rMAC = r2 + Null;
            rmAC = rMAC - r7*r2;
84200164:	4f 00 19 bc 	rMAC = rMAC - r7 * r2 (SS);
            rMAC = rMAC + r7*r3;
84200168:	5f 00 19 ac 	rMAC = rMAC + r7 * r3 (SS);
            M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD] = rMAC;
8420016c:	08 00 13 d5 	M[r1 + 8] = rMAC;
            jump vol_ctrl_update_channel_aux_prio_done;
84200170:	19 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_done;

84200174 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_in_aux>:
        vol_ctrl_update_channel_aux_prio_in_aux:
            // Transition is complete, in aux
            M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD] = r3;
84200174:	08 00 53 d5 	M[r1 + 8] = r3;

            // Check if aux mix not muted
            NULL = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_MUTE_BIT;
84200178:	08 00 0b 81 	Null = r9 AND 0x8;
            if NZ jump vol_ctrl_update_channel_aux_prio_done;
8420017c:	16 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_done;
            // chan_ptr->aux_buffer       = op_extra_data->aux_channel[aux_idx].buffer;
            r7 = M[r8 + $volume_control_cap.vol_ctrl_aux_channel_struct.BUFFER_FIELD];
84200180:	00 00 9a d1 	r7 = M[r8 + 0];
            M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_BUFFER_FIELD] = r7;
84200184:	20 00 93 d5 	M[r1 + 32] = r7;

            // r5=aux_idx, r1=chan_ptr, r6=chan_trim, r4 = chan_idx
            r0 = M[FP+$vol_ctrl.cufp.op_data_ptr];
84200188:	04 00 28 f1 	r0 = M[FP + 0x4];

            // aux_in_use |= (1<<aux_idx);
            r2 = 1 LSHIFT r5;
8420018c:	01 00 47 e9 	r2 = 0x1 LSHIFT r5;
            r3 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_IN_USE_FIELD];
84200190:	e8 02 52 d1 	r3 = M[r0 + 744];
            r3 = r3 OR r2;
84200194:	00 00 54 87 	r3 = r3 OR r2;
            M[r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_IN_USE_FIELD]=r3;
84200198:	e8 02 52 d5 	M[r0 + 744] = r3;

            // aux_params = (vol_ctrl_aux_params_t*)&op_extra_data->parameters.OFFSET_AUX1_SCALE;
            // aux_volume = aux_params[aux_idx].aux_scale;
            r0 = M[FP+$vol_ctrl.cufp.op_data_ptr];
8420019c:	04 00 28 f1 	r0 = M[FP + 0x4];
            r0 = r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD+$volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_AUX1_SCALE_FIELD);
842001a0:	94 01 22 01 	r0 = r0 + 404;
            r2 = r5 * ($volume_control_cap.vol_ctrl_aux_params_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
842001a4:	0c 00 47 99 	r2 = r5 * 12 (int);
            r0 = M[r0 + r2];
842001a8:	00 00 24 d3 	r0 = M[r0 + r2];
            // aux_volume += op_extra_data->lpvols->auxiliary_gain[aux_idx];
            r3 = M[FP + $vol_ctrl.cufp.vol_ptr];
842001ac:	0c 00 58 f1 	r3 = M[FP + 0xc];
            r2 = r5 * ADDR_PER_WORD (int);
842001b0:	04 00 47 99 	r2 = r5 * 4 (int);
            r3 = r3 + r2;
842001b4:	00 00 54 03 	r3 = r3 + r2;
            r3 = M[r3 + $volume_control_cap.vol_ctrl_gains_struct.AUXILIARY_GAIN_FIELD];
842001b8:	08 00 55 d1 	r3 = M[r3 + 8];
            r0 = r0 + r3;
842001bc:	00 00 25 03 	r0 = r0 + r3;
            // chan_ptr->aux_mix_gain  = dB60toLinearQ5(aux_volume+channel_trim);
            r0 = r0 + r6;
842001c0:	00 00 28 03 	r0 = r0 + r6;
            call $_dB60toLinearQ5;
842001c4:	03 00 00 fd 	call (m) 0x37fbe;
842001c8:	bf 7f f0 e1 
            r1 = M[FP + $vol_ctrl.cufp.chan_ptr];
842001cc:	08 00 38 f1 	r1 = M[FP + 0x8];
            M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_MIX_GAIN_FIELD]  = r0;
842001d0:	04 00 23 d5 	M[r1 + 4] = r0;

842001d4 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_done>:

vol_ctrl_update_channel_aux_prio_done:

    r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
842001d4:	04 00 28 f1 	r0 = M[FP + 0x4];

    // r4=chan_idx, r0=op_data_ptr

    // limiter_attn = 0;
    r5 = NULL;
842001d8:	0f 00 70 00 	r5 = Null + Null;

    r1 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD+$volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CONFIG_FIELD)];
842001dc:	90 01 32 d1 	r1 = M[r0 + 400];
    NULL = r1 AND $M.VOL_CTRL.CONFIG.SATURATEENA;
842001e0:	02 00 03 81 	Null = r1 AND 0x2;
    if Z jump vol_ctrl_update_channel_sat_done;
842001e4:	29 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_sat_done;
    r7 = M[FP + $vol_ctrl.cufp.chan_ptr];
842001e8:	08 00 98 f1 	r7 = M[FP + 0x8];
    r8 = M[r7 + $volume_control_cap.vol_ctrl_channel_struct.CHANNEL_GAIN_FIELD];
842001ec:	18 00 a9 d1 	r8 = M[r7 + 24];
    NULL = r8 - $volume_and_limit.MIN_POSITIVE_VOLUME;
842001f0:	00 08 00 fd 	Null = r8 - 134217728;
842001f4:	00 00 0a 21 
    if LE jump vol_ctrl_update_channel_sat_done;
842001f8:	24 00 d0 dd 	if LE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_sat_done;

        // Get Data Buffer
        r6 = r4 * ADDR_PER_WORD (int);
842001fc:	04 00 86 99 	r6 = r4 * 4 (int);
        r6 = r6 + $volume_control_cap._vol_ctrl_data_struct.INPUT_BUFFER_FIELD;
84200200:	00 00 88 01 	r6 = r6 + 0;
        r0 = M[r0 + r6];
84200204:	00 00 28 d3 	r0 = M[r0 + r6];
        call $cbuffer.get_read_address_and_size_and_start_address;
84200208:	03 00 00 fd 	call (m) 0x3a27a;
8420020c:	7b a2 f0 e1 
        I0 = r0;
84200210:	2f 00 00 50 	I0 = Null + r0;
        L0 = r1;
84200214:	3f 00 c0 50 	L0 = Null + r1;
        push r2;
84200218:	00 00 40 f3 	push r2;
        pop B0;
8420021c:	00 00 a6 f3 	pop B0;

        // Compute Peak
        r3 = M[FP + $vol_ctrl.cufp.tc_ptr];
84200220:	10 00 58 f1 	r3 = M[FP + 0x10];
        r10 = M[r3+$volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD];
84200224:	00 00 c5 d1 	r10 = M[r3 + 0];
        r2 = M[r3+$volume_control_cap.vol_time_constants_struct.SAT_TCP5_FIELD];
84200228:	0c 00 45 d1 	r2 = M[r3 + 12];
        r3 = M[r7 + $volume_control_cap.vol_ctrl_channel_struct.LAST_PEAK_FIELD];
8420022c:	14 00 59 d1 	r3 = M[r7 + 20];
        r10 = r10 - 1;
84200230:	3f 00 cc e4 	r10 = r10 - 1;
        // Use history for peak but decay it based on num samples
        r3 = r3 * r2 (frac), r2=M[I0,M1];
84200234:	00 41 54 96 	r3 = r3 * r2 (frac), r2 = M[I0,M1];
        do vol_ctrl_update_channel_peak_lp;
84200238:	03 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_update_channel_peak_lp;
            r2 = ABS r2;
8420023c:	4f 00 44 e4 	r2 = ABS r2;
            r3 = MAX r2, r2=M[I0,M1];
84200240:	6f 41 54 e4 	r3 = MAX r2, r2 = M[I0,M1];

84200244 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_peak_lp>:
        vol_ctrl_update_channel_peak_lp:
        r2 = ABS r2;
84200244:	4f 00 44 e4 	r2 = ABS r2;
        r3 = MAX r2;
84200248:	6f 00 54 e4 	r3 = MAX r2;
        M[r7 + $volume_control_cap.vol_ctrl_channel_struct.LAST_PEAK_FIELD]=r3;
8420024c:	14 00 59 d5 	M[r7 + 20] = r3;

        // max_abs = MAX(ABS(channel data)) * chan_ptr->channel_gain;
        rMAC = r3 * r8;
84200250:	af 00 15 cc 	rMAC = r3 * r8 (SS);

        r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
84200254:	04 00 28 f1 	r0 = M[FP + 0x4];
        r1 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_LIMIT_THRESHOLD_LINEAR_FIELD)];
84200258:	a4 02 32 d1 	r1 = M[r0 + 676];
        NULL = rMAC - r1;
8420025c:	3f 00 01 20 	Null = rMAC - r1;
        if NEG jump vol_ctrl_update_channel_sat_done;
84200260:	0a 00 40 dd 	if NEG jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_sat_done;

        r7 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_LIMIT_ADAPTATION_RATIO_FIELD)];
84200264:	a8 02 92 d1 	r7 = M[r0 + 680];
        r9 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_LIMIT_THRESHOLD_LOG_FIELD)];
84200268:	ac 02 b2 d1 	r9 = M[r0 + 684];

        // limiter_attn = (LIMIT_THRESHOLD - log2(max_abs)) * LIMIT_RATIO;
        call $math.log2_table;
8420026c:	07 00 00 fd 	call 0x745ac;
84200270:	ac 45 f0 e1 
        /* Input to log was Q5.xx,  need to adjust to Q1.xx */
        r0 = r0 + (4<<(DAWTH-8));
84200274:	00 04 00 fd 	r0 = r0 + 67108864;
84200278:	00 00 22 01 
        r9 = r9 - r0;
8420027c:	00 00 b2 23 	r9 = r9 - r0;
        r5 = r9 * r7 (frac);
84200280:	9f 00 7b 94 	r5 = r9 * r7 (frac);
        if POS r5=NULL;
84200284:	05 00 70 00 	if POS r5 = Null + Null;

84200288 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_sat_done>:
vol_ctrl_update_channel_sat_done:

    // Time constants are scaled based on num samples
    r1 = M[FP+$vol_ctrl.cufp.chan_ptr];
84200288:	08 00 38 f1 	r1 = M[FP + 0x8];
    r2 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LIMIT_GAIN_LOG2_FIELD];
8420028c:	0c 00 43 d1 	r2 = M[r1 + 12];
    r3 = M[FP + $vol_ctrl.cufp.tc_ptr];
84200290:	10 00 58 f1 	r3 = M[FP + 0x10];
    r4 = M[r3 + $volume_control_cap.vol_time_constants_struct.SAT_TC_FIELD];
84200294:	08 00 65 d1 	r4 = M[r3 + 8];
    r3 = M[r3 + $volume_control_cap.vol_time_constants_struct.SAT_TCP5_FIELD];
84200298:	0c 00 55 d1 	r3 = M[r3 + 12];
    NULL = r5 - r2;
8420029c:	4f 00 07 20 	Null = r5 - r2;
    if POS r3 = r4;
842002a0:	05 00 56 00 	if POS r3 = r4 + Null;

    // chan_ptr->limit_gain_log2 = (1.0 - tc)*limiter_attn + tc*chan_ptr->limit_gain_log2;
    // chan_ptr->limit_gain_log2 = MIN(chan_ptr->limit_gain_log2,0);
    rMAC = r5;
842002a4:	0f 00 17 00 	rMAC = r5 + Null;
    rMAC = rMAC - r3*r5;
842002a8:	7f 00 15 bc 	rMAC = rMAC - r3 * r5 (SS);
    rMAC = rMAC + r3*r2;
842002ac:	4f 00 15 ac 	rMAC = rMAC + r3 * r2 (SS);
    if POS rMAC = NULL;
842002b0:	05 00 10 00 	if POS rMAC = Null + Null;

    r3 = r5 - rMAC;
842002b4:	1f 00 57 20 	r3 = r5 - rMAC;
    r3 = ABS r3;
842002b8:	4f 00 55 e4 	r3 = ABS r3;
    NULL = r3 - 0.00001;
842002bc:	e3 53 05 21 	Null = r3 - 21475;
    if LE rMAC = r5;
842002c0:	0d 00 17 00 	if LE rMAC = r5 + Null;

    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LIMIT_GAIN_LOG2_FIELD]=rMAC;
842002c4:	0c 00 13 d5 	M[r1 + 12] = rMAC;

    // r1 = chan_ptr

    L0 = NULL;
842002c8:	0f 00 c0 50 	L0 = Null + Null;
    push NULL;
842002cc:	00 00 00 f3 	push Null;
    pop B0;
842002d0:	00 00 a6 f3 	pop B0;

    /* channel count */
    pop r7;
842002d4:	00 00 94 f3 	pop r7;

    /* advance channel */
    r1 = r1 + ($volume_control_cap.vol_ctrl_channel_struct.STRUC_SIZE*ADDR_PER_WORD);
842002d8:	24 00 33 01 	r1 = r1 + 36;
    M[FP + $vol_ctrl.cufp.chan_ptr] = r1;
842002dc:	08 00 3c f1 	M[FP + 0x8] = r1;

    /* restore data */
    r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
842002e0:	04 00 28 f1 	r0 = M[FP + 0x4];
    r2 = M[FP + $vol_ctrl.cufp.vol_ptr];
842002e4:	0c 00 48 f1 	r2 = M[FP + 0xc];

    /* Another channel ? */
    r7 = r7 - 1;
842002e8:	3f 00 99 e4 	r7 = r7 - 1;
    if GT jump vol_ctrl_update_channel_next;
842002ec:	50 ff c0 dd 	if GT jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_next;

842002f0 <$_vol_ctrl_update_saturation>:
//    Function is C compatible
//
// *****************************************************************************
$_vol_ctrl_update_saturation:
    /* Saturation protection may be per channel or across all channels */
    r1 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CONFIG_FIELD)];
842002f0:	90 01 32 d1 	r1 = M[r0 + 400];
    NULL = r1 AND $M.VOL_CTRL.CONFIG.SATURATEENA;
842002f4:	02 00 03 81 	Null = r1 AND 0x2;
    if Z jump vol_ctrl_update_saturation_done;
842002f8:	1a 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_conv_lp;

        r2 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.CHANNELS_FIELD];
842002fc:	68 00 42 d1 	r2 = M[r0 + 104];
        r10 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.NUM_CHANNELS_FIELD];
84200300:	5c 00 c2 d1 	r10 = M[r0 + 92];
        M3 = ($volume_control_cap.vol_ctrl_channel_struct.STRUC_SIZE * ADDR_PER_WORD);
84200304:	24 00 b0 51 	M3 = Null + 36;
        I0 = r2 + $volume_control_cap.vol_ctrl_channel_struct.LIMIT_GAIN_LOG2_FIELD;
84200308:	0c 00 04 51 	I0 = r2 + 12;
        I1 = r2 + $volume_control_cap.vol_ctrl_channel_struct.LIMITER_GAIN_LINEAR_FIELD;
8420030c:	10 00 14 51 	I1 = r2 + 16;

        NULL = r1 AND $M.VOL_CTRL.CONFIG.SATURATESYNCENA;
84200310:	04 00 03 81 	Null = r1 AND 0x4;
        if Z jump vol_ctrl_update_saturation_not_sync;
84200314:	0e 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_not_sync;
            // Min log gain of channels
            push r10,    r1 = M[I0,M3];
84200318:	00 33 c0 f2 	push r10, r1 = M[I0,M3];
            r10 = r10 - 1;
8420031c:	3f 00 cc e4 	r10 = r10 - 1;
            r0  = r1;
84200320:	0f 00 23 00 	r0 = r1 + Null;
            do vol_ctrl_update_saturation_min_lp;
84200324:	02 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_min_lp;
                r0 = MIN r1, r1 = M[I0,M3];
84200328:	5f 33 23 e4 	r0 = MIN r1, r1 = M[I0,M3];

8420032c <$M.vol_ctrl_update_channel.vol_ctrl_update_saturation_min_lp>:
            vol_ctrl_update_saturation_min_lp:
            r0 = MIN r1;
8420032c:	5f 00 23 e4 	r0 = MIN r1;
            // Convert to linear
            call $math.pow2_table;
84200330:	07 00 00 fd 	call 0x74514;
84200334:	14 45 f0 e1 
            // Apply to all channels
            pop r10;
84200338:	00 00 c4 f3 	pop r10;
            // Nops ensures pipeline for setting r10
            nop;
8420033c:	00 00 00 03 	Null = Null + Null;
            do vol_ctrl_update_saturation_apply_lp;
84200340:	02 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_apply_lp;
                M[I1,M3]=r0;
84200344:	00 a7 00 02 	Null = Null + Null, M[I1,M3] = r0;

84200348 <$M.vol_ctrl_update_channel.vol_ctrl_update_saturation_apply_lp>:
            vol_ctrl_update_saturation_apply_lp:
            jump vol_ctrl_update_saturation_done;
84200348:	06 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_conv_lp;

8420034c <$M.vol_ctrl_update_channel.vol_ctrl_update_saturation_not_sync>:

        vol_ctrl_update_saturation_not_sync:
            // Convert to linear
            do vol_ctrl_update_saturation_conv_lp;
8420034c:	05 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_conv_lp;
                r0 = M[I0,M3];
84200350:	00 23 00 02 	Null = Null + Null, r0 = M[I0,M3];
                call $math.pow2_table;
84200354:	07 00 00 fd 	call 0x74514;
84200358:	14 45 f0 e1 
                M[I1,M3]=r0;
8420035c:	00 a7 00 02 	Null = Null + Null, M[I1,M3] = r0;

84200360 <$M.vol_ctrl_update_channel.vol_ctrl_update_saturation_conv_lp>:
           vol_ctrl_apply_volume(op_extra_data,&op_extra_data->channels[i],&volume_tc);
       }
   */
$_vol_ctrl_apply_volume:

    r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
84200360:	04 00 28 f1 	r0 = M[FP + 0x4];

    /* Number of channels */
    r7 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.NUM_CHANNELS_FIELD];
84200364:	5c 00 92 d1 	r7 = M[r0 + 92];

    // Reset chan_ptr
    r1 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.CHANNELS_FIELD];
84200368:	68 00 32 d1 	r1 = M[r0 + 104];
    M[FP + $vol_ctrl.cuup.chan_ptr]=r1;
8420036c:	08 00 3c f1 	M[FP + 0x8] = r1;

    // Move time constants */
    r2 = M[FP + $vol_ctrl.cufp.tc_ptr];
84200370:	10 00 48 f1 	r2 = M[FP + 0x10];
    M[FP + $vol_ctrl.cuup.tc_ptr] = r2;
84200374:	0c 00 4c f1 	M[FP + 0xc] = r2;

84200378 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_next>:
    // r0: VOL_CTRL_DATA_T *op_extra_data
    // r1: vol_ctrl_channel_t *chan_ptr
    // r2: vol_time_constants_t *lpvcs

vol_ctrl_apply_volume_next:
    push r7;
84200378:	00 00 90 f3 	push r7;
    // r0: VOL_CTRL_DATA_T *op_extra_data
    // r1: vol_ctrl_channel_t *chan_ptr
    // r2: vol_time_constants_t *lpvcs

    // r3: routing
    r7 = r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CHAN1_AUX_ROUTE_FIELD);
8420037c:	f4 01 92 01 	r7 = r0 + 500;
    r6 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHAN_IDX_FIELD];
84200380:	00 00 83 d1 	r6 = M[r1 + 0];
    r6 = r6  * ($volume_control_cap.vol_ctrl_chan_params_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
84200384:	14 00 88 99 	r6 = r6 * 20 (int);
    r3 = M[r7+r6];
84200388:	8f 00 59 d0 	r3 = M[r7 + r6];

    // Boost
    r8 = $volume_and_limit.OneQ5;
8420038c:	00 08 00 fd 	r8 = Null + 134217728;
84200390:	00 00 a0 01 
    r5  = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_BOOST_FIELD)];
84200394:	9c 02 72 d1 	r5 = M[r0 + 668];
    NULL = r3 AND $M.VOL_CTRL.CONSTANT.CHAN_BOOST_CLIP_ENABLE_BIT;
84200398:	20 00 00 fd 	Null = r3 AND 0x200000;
8420039c:	00 00 05 81 
    if Z r5 = r8;
842003a0:	00 00 7a 00 	if EQ r5 = r8 + Null;

    // Gains
    r9  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHANNEL_GAIN_FIELD];        // Q5.xx
842003a4:	18 00 b3 d1 	r9 = M[r1 + 24];
    r10 = M[r2 + $volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD];
842003a8:	00 00 c4 d1 	r10 = M[r2 + 0];
    r7  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD];       // Q5.xx
842003ac:	08 00 93 d1 	r7 = M[r1 + 8];
    r6  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LIMITER_GAIN_LINEAR_FIELD]; // Q.xx
842003b0:	10 00 83 d1 	r6 = M[r1 + 16];

    // calculate init and final volume for this frame
    rMAC = r9 * r6;
842003b4:	8f 00 1b cc 	rMAC = r9 * r6 (SS);
    rMAC = rMAC * r7;
842003b8:	9f 00 11 cc 	rMAC = rMAC * r7 (SS);
    rMAC = rMAC ASHIFT 4 (56bit);
842003bc:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
    rMAC = rMAC * r5;
842003c0:	7f 00 11 cc 	rMAC = rMAC * r5 (SS);
    rMAC = rMAC ASHIFT 4 (56bit);  // Boost
842003c4:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);

    // Compute the volume step size
    r4  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LAST_VOLUME_FIELD];         // Q5.xx
842003c8:	1c 00 63 d1 	r4 = M[r1 + 28];
    r2 = rMAC - r4;
842003cc:	6f 00 41 20 	r2 = rMAC - r4;
    rMAC = r2 ASHIFT 0 (LO);
842003d0:	00 01 e4 91 	rMAC = r2 ASHIFT 0 (LO);
    Div = rMAC / r10;
842003d4:	00 00 1c d9 	Div = rMAC / r10;

    // Aux Mix
    r8  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_MIX_GAIN_FIELD];        // Q5.xx
842003d8:	04 00 a3 d1 	r8 = M[r1 + 4];
    rMAC = r8 * r5;
842003dc:	7f 00 1a cc 	rMAC = r8 * r5 (SS);
    r8 = rMAC ASHIFT 4;  // Boost
842003e0:	04 00 a1 91 	r8 = rMAC ASHIFT 4;

    /* Adjust Clip Point
       (might as well do it even if we don't use it, divide takes time anyway) */
    r5 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CLIP_POINT_FIELD)];
842003e4:	94 02 72 d1 	r5 = M[r0 + 660];
    r2 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_BOOST_CLIP_POINT_FIELD)];
842003e8:	98 02 42 d1 	r2 = M[r0 + 664];
    // Multiply the Clip Point (r5) with the Inverse Post Gain (r7)
    r7 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.SHARED_VOLUME_PTR_FIELD];
842003ec:	8c 01 92 d1 	r7 = M[r0 + 396];
    r7 = M[r7 + $volume_control_cap._shared_volume_struct.INV_POST_GAIN_FIELD];
842003f0:	0c 00 99 d1 	r7 = M[r7 + 12];
    // The inverse DAC gain is Q5.xx, so we need to shift r7 to get Q1.xx
    rMAC = r5 * r7;
842003f4:	9f 00 17 cc 	rMAC = r5 * r7 (SS);
    r7 = rMAC ASHIFT 4;
842003f8:	04 00 91 91 	r7 = rMAC ASHIFT 4;
    // limit the clipper threshold so DAC wrap bug doesn't occur
    Null = r7 - r2;
842003fc:	4f 00 09 20 	Null = r7 - r2;
    if POS r7 = r2;
84200400:	05 00 94 00 	if POS r7 = r2 + Null;

    // Step for main volume
    r5 = DivResult;
84200404:	01 00 70 d9 	r5 = DivResult;

    // Setup Buffers
    pushm <r3,r10>;
84200408:	20 10 00 f1 	pushm <r3, r10>;

    r1 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHAN_IDX_FIELD];
8420040c:	00 00 33 d1 	r1 = M[r1 + 0];
    r1 = r1 * ADDR_PER_WORD (int);
84200410:	04 00 33 99 	r1 = r1 * 4 (int);
    r0 = r0 + r1;
84200414:	00 00 23 03 	r0 = r0 + r1;
    push r0;
84200418:	00 00 20 f3 	push r0;
    r0 = M[r0];
8420041c:	00 00 20 d3 	r0 = M[r0 + Null];
    call $cbuffer.get_read_address_and_size_and_start_address;
84200420:	03 00 00 fd 	call (m) 0x3a27a;
84200424:	7b a2 f0 e1 
    I0 = r0;
84200428:	2f 00 00 50 	I0 = Null + r0;
    push r2;
8420042c:	00 00 40 f3 	push r2;
    pop  B0;
84200430:	00 00 a6 f3 	pop B0;
    L0 = r1;
84200434:	3f 00 c0 50 	L0 = Null + r1;

    pop r0;
84200438:	00 00 24 f3 	pop r0;
    r0 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.OUTPUT_BUFFER_FIELD];
8420043c:	20 00 22 d1 	r0 = M[r0 + 32];
    call $cbuffer.get_write_address_and_size_and_start_address;
84200440:	03 00 00 fd 	call (m) 0x3a2b0;
84200444:	b1 a2 f0 e1 
    I5 = r0;
84200448:	2f 00 50 50 	I5 = Null + r0;
    push r2;
8420044c:	00 00 40 f3 	push r2;
    pop B5;
84200450:	00 00 d6 f3 	pop B5;
    L5 = r1;
84200454:	3f 00 f0 50 	L5 = Null + r1;

    r1 = M[FP + $vol_ctrl.cuup.chan_ptr];
84200458:	08 00 38 f1 	r1 = M[FP + 0x8];
    r0 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_BUFFER_FIELD];
8420045c:	20 00 23 d1 	r0 = M[r1 + 32];
    if NZ jump vol_ctrl_apply_volume_get_aux;
84200460:	06 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_get_aux;
        r0 = FP + $vol_ctrl.cuup.dummy;
84200464:	10 00 27 f1 	r0 = FP + 16;
        r1 = ADDR_PER_WORD;
84200468:	bf 00 30 e4 	r1 = Null + 4;
        r2 = r0;
8420046c:	0f 00 42 00 	r2 = r0 + Null;
        r8 = NULL;
84200470:	0f 00 a0 00 	r8 = Null + Null;
        jump vol_ctrl_apply_volume_get_aux_ok;
84200474:	03 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_get_aux_ok;

84200478 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_get_aux>:
    vol_ctrl_apply_volume_get_aux:
        call $cbuffer.get_read_address_and_size_and_start_address;
84200478:	03 00 00 fd 	call (m) 0x3a27a;
8420047c:	7b a2 f0 e1 

84200480 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_get_aux_ok>:
  vol_ctrl_apply_volume_get_aux_ok:
    // Set Aux pointer
    I4 = r0;
84200480:	2f 00 40 50 	I4 = Null + r0;
    push r2;
84200484:	00 00 40 f3 	push r2;
    pop B4;
84200488:	00 00 c6 f3 	pop B4;
    L4 = r1;
8420048c:	3f 00 e0 50 	L4 = Null + r1;

    popm <r3,r10>;
84200490:	20 10 04 f1 	popm <r3, r10>;
    // r7=clip, r4=main gain, r8=aux gain, r3=routing, r10 = amount

    /* Check Mute */
    r0 = M[FP + $vol_ctrl.cuup.op_data_ptr];
84200494:	04 00 28 f1 	r0 = M[FP + 0x4];
    r6 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.CUR_MUTE_GAIN_FIELD];
84200498:	04 03 82 d1 	r6 = M[r0 + 772];
    r9 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.MUTE_INCREMENT_FIELD];
8420049c:	08 03 b2 d1 	r9 = M[r0 + 776];
    if NZ jump vol_ctrl_apply_volume_mute;
842004a0:	16 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_mute;

    NULL = r3 AND $M.VOL_CTRL.CONSTANT.CHAN_BOOST_CLIP_ENABLE_BIT;
842004a4:	20 00 00 fd 	Null = r3 AND 0x200000;
842004a8:	00 00 05 81 
    if NZ jump vol_ctrl_apply_volume_clip;
842004ac:	08 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip;
        do vol_ctrl_apply_volume_lp;
842004b0:	06 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_lp;
            r4 = r4 + r5,   r2 = M[I0,MK1];
842004b4:	00 41 67 03 	r4 = r4 + r5, r2 = M[I0,4];
            rMAC = r2 * r4, r2 = M[I4,MK1];
842004b8:	41 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I4,4];
            rMAC = rMAC + r2 * r8;
842004bc:	af 00 14 ac 	rMAC = rMAC + r2 * r8 (SS);
            rMAC = rMAC ASHIFT 4 (56bit);
842004c0:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
            M[I5,MK1] = rMAC;
842004c4:	95 00 00 03 	Null = Null + Null, M[I5,4] = rMAC;

842004c8 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_lp>:
        vol_ctrl_apply_volume_lp:
        jump vol_ctrl_apply_volume_done;
842004c8:	26 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp;

842004cc <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip>:

    vol_ctrl_apply_volume_clip:
        do vol_ctrl_apply_volume_clip_lp;
842004cc:	0a 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_lp;
            r4 = r4 + r5,   r2 = M[I0,MK1];
842004d0:	00 41 67 03 	r4 = r4 + r5, r2 = M[I0,4];
            rMAC = r2 * r4, r2 = M[I4,MK1];
842004d4:	41 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I4,4];
            rMAC = rMAC + r2 * r8;
842004d8:	af 00 14 ac 	rMAC = rMAC + r2 * r8 (SS);
            rMAC = rMAC ASHIFT 4 (56bit);
842004dc:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
            // Hard Clip
            r1 = rMAC ASHIFT (8 + 2 * DAWTH);
842004e0:	48 00 31 91 	r1 = rMAC ASHIFT 72;
            r2 = ABS rMAC;
842004e4:	4f 00 41 e4 	r2 = ABS rMAC;
            r2 = MIN r7;
842004e8:	5f 00 49 e4 	r2 = MIN r7;
            r2 = r2 * r1 (frac);
842004ec:	00 00 43 97 	r2 = r2 * r1 (frac);
            M[I5,MK1] = r2;
842004f0:	c5 00 00 03 	Null = Null + Null, M[I5,4] = r2;

842004f4 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_lp>:
        vol_ctrl_apply_volume_clip_lp:
        jump vol_ctrl_apply_volume_done;
842004f4:	1b 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp;

842004f8 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_mute>:

vol_ctrl_apply_volume_mute:
        NULL = r3 AND $M.VOL_CTRL.CONSTANT.CHAN_BOOST_CLIP_ENABLE_BIT;
842004f8:	20 00 00 fd 	Null = r3 AND 0x200000;
842004fc:	00 00 05 81 
        if NZ jump vol_ctrl_apply_volume_clip_mute;
84200500:	0b 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute;

        do vol_ctrl_apply_volume_mute_lp;
84200504:	09 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_mute_lp;
            r4 = r4 + r5,   r2 = M[I0,MK1];
84200508:	00 41 67 03 	r4 = r4 + r5, r2 = M[I0,4];
            rMAC = r2 * r4, r2 = M[I4,MK1];
8420050c:	41 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I4,4];
            rMAC = rMAC + r2 * r8;
84200510:	af 00 14 ac 	rMAC = rMAC + r2 * r8 (SS);
            rMAC = rMAC ASHIFT 4 (56bit);
84200514:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
            // Mute
            r6 = r6 + r9;
84200518:	00 00 8b 03 	r6 = r6 + r9;
            if NEG r6=NULL;
8420051c:	04 00 80 00 	if NEG r6 = Null + Null;
            rMAC = rMAC * r6 (frac);
84200520:	00 00 18 97 	rMAC = rMAC * r6 (frac);
            // Save result
            M[I5,MK1] = rMAC;
84200524:	95 00 00 03 	Null = Null + Null, M[I5,4] = rMAC;

84200528 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_mute_lp>:
        vol_ctrl_apply_volume_mute_lp:
        jump vol_ctrl_apply_volume_done;
84200528:	0e 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp;

8420052c <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute>:

vol_ctrl_apply_volume_clip_mute:
        do vol_ctrl_apply_volume_clip_mute_lp;
8420052c:	0d 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp;
            r4 = r4 + r5,   r2 = M[I0,MK1];
84200530:	00 41 67 03 	r4 = r4 + r5, r2 = M[I0,4];
            rMAC = r2 * r4, r2 = M[I4,MK1];
84200534:	41 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I4,4];
            rMAC = rMAC + r2 * r8;
84200538:	af 00 14 ac 	rMAC = rMAC + r2 * r8 (SS);
            rMAC = rMAC ASHIFT 4 (56bit);
8420053c:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
            // Hard Clip
            r1 = rMAC ASHIFT (8 + 2 * DAWTH);
84200540:	48 00 31 91 	r1 = rMAC ASHIFT 72;
            r2 = ABS rMAC;
84200544:	4f 00 41 e4 	r2 = ABS rMAC;
            r2 = MIN r7;
84200548:	5f 00 49 e4 	r2 = MIN r7;
            r2 = r2 * r1 (frac);
8420054c:	00 00 43 97 	r2 = r2 * r1 (frac);
            // Mute
            r6 = r6 + r9;
84200550:	00 00 8b 03 	r6 = r6 + r9;
            if NEG r6=NULL;
84200554:	04 00 80 00 	if NEG r6 = Null + Null;
            r2 = r2 * r6 (frac);
84200558:	00 00 48 97 	r2 = r2 * r6 (frac);
            // Save result
            M[I5,MK1] = r2;
8420055c:	c5 00 00 03 	Null = Null + Null, M[I5,4] = r2;

84200560 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp>:
        vol_ctrl_apply_volume_clip_mute_lp:

vol_ctrl_apply_volume_done:

    // Save last gain
    r1 = M[FP +$vol_ctrl.cuup.chan_ptr];
84200560:	08 00 38 f1 	r1 = M[FP + 0x8];
    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LAST_VOLUME_FIELD] = r4;
84200564:	1c 00 63 d5 	M[r1 + 28] = r4;

    // Update Buffer
    r1 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHAN_IDX_FIELD];
84200568:	00 00 33 d1 	r1 = M[r1 + 0];
    r1 = r1 * ADDR_PER_WORD(int);
8420056c:	04 00 33 99 	r1 = r1 * 4 (int);
    r0 = M[FP + $vol_ctrl.cuup.op_data_ptr];
84200570:	04 00 28 f1 	r0 = M[FP + 0x4];
    r0 = r0 + r1;
84200574:	00 00 23 03 	r0 = r0 + r1;
    push r0;
84200578:	00 00 20 f3 	push r0;
    r0 = M[r0];
8420057c:	00 00 20 d3 	r0 = M[r0 + Null];
    r1 = I0;
84200580:	0f 00 30 44 	r1 = Null + I0;
    call $cbuffer.set_read_address;
84200584:	03 00 00 fd 	call (m) 0x3a2e6;
84200588:	e7 a2 f0 e1 
    pop r0;
8420058c:	00 00 24 f3 	pop r0;
    r0 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.OUTPUT_BUFFER_FIELD];
84200590:	20 00 22 d1 	r0 = M[r0 + 32];
    r1 = I5;
84200594:	5f 00 30 44 	r1 = Null + I5;
    call $cbuffer.set_write_address;
84200598:	03 00 00 fd 	call (m) 0x3a320;
8420059c:	21 a3 f0 e1 

    /* Next Channel */
    pop r7;
842005a0:	00 00 94 f3 	pop r7;

    /* Restore parameters */
    r0 = M[FP + $vol_ctrl.cuup.op_data_ptr];
842005a4:	04 00 28 f1 	r0 = M[FP + 0x4];
    r1 = M[FP + $vol_ctrl.cuup.chan_ptr];
842005a8:	08 00 38 f1 	r1 = M[FP + 0x8];
    r2 = M[FP + $vol_ctrl.cuup.tc_ptr];
842005ac:	0c 00 48 f1 	r2 = M[FP + 0xc];

    /* advance chan_ptr */
    r1 = r1 + ($volume_control_cap.vol_ctrl_channel_struct.STRUC_SIZE*ADDR_PER_WORD);
842005b0:	24 00 33 01 	r1 = r1 + 36;
    M[FP + $vol_ctrl.cuup.chan_ptr]=r1;
842005b4:	08 00 3c f1 	M[FP + 0x8] = r1;

    /* Another channel */
    r7 = r7 - 1;
842005b8:	3f 00 99 e4 	r7 = r7 - 1;
    if GT jump vol_ctrl_apply_volume_next;
842005bc:	6f ff c0 dd 	if GT jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_next;

    // Save current mute
    M[r0 + $volume_control_cap._vol_ctrl_data_struct.CUR_MUTE_GAIN_FIELD]=r6;
842005c0:	04 03 82 d5 	M[r0 + 772] = r6;
    NULL = r6 - 1.0;
842005c4:	ff 7f 00 fd 	Null = r6 - 2147483647;
842005c8:	ff ff 08 21 
    if Z r9=NULL;
842005cc:	00 00 b0 00 	if EQ r9 = Null + Null;
    M[r0 + $volume_control_cap._vol_ctrl_data_struct.MUTE_INCREMENT_FIELD]=r9;
842005d0:	08 03 b2 d5 	M[r0 + 776] = r9;

    // Restore arithmetic mode */
    pop r4;
842005d4:	00 00 64 f3 	pop r4;
    M[$ARITHMETIC_MODE]=r4;
842005d8:	14 e0 60 19 	M[0xffffe014] = r4 + Null;

842005dc <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_abort>:

vol_ctrl_apply_volume_abort:

    popm <FP,r0,r1,r2,r3,rlink>;
842005dc:	3d 20 04 f1 	popm <FP, r0, r1, r2, r3, rLink>;
    popm <B0,B4,B5>;
842005e0:	00 34 06 f1 	popm <B0, B4, B5>;
    popm <I0,I1,I4,I5,M3,L0,L4,L5>;
842005e4:	33 d8 05 f1 	popm <I0, I1, I4, I5, M3, L0, L4, L5>;
    popm <r4,r5,r6,r7,r8,r9>;
842005e8:	c0 0f 04 f1 	popm <r4, r5, r6, r7, r8, r9>;

    rts;
842005ec:	0f 00 0d dc 	rts;
Disassembly of section .text_minim:

842005f0 <$_setup_processing>:
    op_extra_data->mute_increment = (bMute) ? -mute_increment : mute_increment;

}

bool setup_processing(VOL_CTRL_DATA_T   *op_extra_data)
{
842005f0:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842005f2:	11 09       	r7 = r0 + Null;
    unsigned touched_sink = TOUCHED_NOTHING;
842005f4:	06 00       	r4 = Null + Null;
    unsigned touched_src  = TOUCHED_NOTHING;
842005f6:	07 00       	r5 = Null + Null;
    unsigned i,sink_bit,initial_channel_gain,chan_count=0;
842005f8:	00 09       	r6 = Null + Null;
    vol_ctrl_channel_t *chan_ptr;
	vol_ctrl_gains_t *lpvols =&op_extra_data->host_vol;
842005fa:	9a f0 f8 20 	r8 = r7 + 248;

    patch_fn_shared(volume_control_wrapper);

    /* Release data object */
    destroy_processing(op_extra_data);
842005fe:	6a 4e       	call (m) $_destroy_processing;


    /* Validate channel sinks and sources.  Count connected channels   */
    for(i=0,sink_bit=0;i<VOL_CTRL_CONSTANT_NUM_CHANNELS;i++,sink_bit+=2)
84200600:	01 00       	rMAC = Null + Null;
84200602:	02 00       	r0 = Null + Null;
84200604:	93 f0 20 20 	r1 = r7 + 32;

84200608 <Lc_setup_processing_2>:
    {
        if(op_extra_data->input_buffer[i])
84200608:	34 f3 f8 b9 	r2 = M[r1 + -32];
8420060c:	43 60       	if EQ jump (m) Lc_setup_processing_12;

8420060e <Lc_setup_processing_3>:
        {
            if(op_extra_data->output_buffer[i])
8420060e:	1c e8       	r2 = M[r1 + Null];
84200610:	43 60       	if EQ jump (m) Lc_setup_processing_13;

84200612 <Lc_setup_processing_4>:
            {
                chan_count++;
84200612:	08 75       	r6 = r6 + 1;
                touched_sink |= ( TOUCHED_SINK_0 <<sink_bit );
84200614:	14 00       	r2 = r0 + Null;
84200616:	00 f4 94 de 	r2 = 0x1 LSHIFT r2;
8420061a:	36 13       	r4 = r4 OR r2;
                touched_src  |=  (TOUCHED_SOURCE_0 << i);
8420061c:	0c 00       	r2 = rMAC + Null;
8420061e:	00 f4 94 de 	r2 = 0x1 LSHIFT r2;
84200622:	3f 13       	r5 = r5 OR r2;

84200624 <Lc_setup_processing_5>:
    /* Release data object */
    destroy_processing(op_extra_data);


    /* Validate channel sinks and sources.  Count connected channels   */
    for(i=0,sink_bit=0;i<VOL_CTRL_CONSTANT_NUM_CHANNELS;i++,sink_bit+=2)
84200624:	49 20       	rMAC = rMAC + 1;
84200626:	92 20       	r0 = r0 + 2;
84200628:	1b 21       	r1 = r1 + 4;
8420062a:	08 26       	Null = rMAC - 8;
8420062c:	ee 65       	if NC jump (m) Lc_setup_processing_2;

8420062e <Lc_setup_processing_6>:
            return FALSE;
        }
    }

    /* Must have at least one channel */
    if(chan_count<1)
8420062e:	0f f8 00 c2 	Null = r6 - Null;
84200632:	32 60       	if EQ jump (m) Lc_setup_processing_13;

84200634 <Lc_setup_processing_7>:
    {
        return FALSE;
    }

    /* A valid set of channels is connected */
    op_extra_data->channels = (vol_ctrl_channel_t*)xzpmalloc(chan_count*sizeof(vol_ctrl_channel_t));
84200634:	c3 20       	r1 = Null + 3;
84200636:	12 f8 92 c9 	r0 = r6 * 36 (int);
8420063a:	ff fd 31 f0 	call (m) 0x68a6;
8420063e:	2d e3 
    if(!op_extra_data->channels)
84200640:	92 f0 1a 8e 	M[r7 + 104] = r0;
84200644:	29 60       	if EQ jump (m) Lc_setup_processing_13;

84200646 <Lc_setup_processing_8>:
    {
        return FALSE;
    }
    op_extra_data->touched_src  = touched_src;
84200646:	97 f0 19 8e 	M[r7 + 100] = r5;
    op_extra_data->touched_sink = touched_sink;
8420064a:	96 f0 18 8e 	M[r7 + 96] = r4;
    op_extra_data->num_channels = chan_count;
8420064e:	98 f0 17 8e 	M[r7 + 92] = r6;

    /* Initialize Mute */
    op_extra_data->cur_mute_gain = 0;
84200652:	90 f0 c1 8e 	M[r7 + 772] = Null;
    vol_ctrl_setup_mute(op_extra_data,lpvols->mute);
84200656:	a3 f0 01 88 	r1 = M[r8 + 4];
8420065a:	4a 08       	r0 = r7 + Null;
8420065c:	09 f0 2f e1 	call (m) Lc_vol_ctrl_setup_mute_1;

    /* Link Channels with channel object */
    chan_ptr = op_extra_data->channels;
84200660:	96 f0 1a 88 	r4 = M[r7 + 104];
    for(i=0;i<VOL_CTRL_CONSTANT_NUM_CHANNELS;i++)
84200664:	07 00       	r5 = Null + Null;
84200666:	98 f0 20 20 	r6 = r7 + 32;

8420066a <Lc_setup_processing_9>:
    {
        if(op_extra_data->output_buffer[i])
8420066a:	81 f0 00 e8 	rMAC = M[r6 + Null];
8420066e:	21 60       	if EQ jump (m) Lc_setup_processing_16;

84200670 <Lc_setup_processing_10>:
        {
		    /* If initial value not specified before operator start, use -96db as default
			 * If an initial value is specified calculate channel gain as master_gain + channel_trim - post gain
			 */
		    if(op_extra_data->vol_initialised)
84200670:	90 f0 bf 88 	Null = M[r7 + 764];
84200674:	13 60       	if EQ jump (m) Lc_setup_processing_14;

84200676 <Lc_setup_processing_11>:
		    {
			    initial_channel_gain = dB60toLinearQ5(op_extra_data->lpvols->channel_trims[i] + op_extra_data->lpvols->master_gain - op_extra_data->post_gain);
84200676:	91 f0 62 88 	rMAC = M[r7 + 392];
8420067a:	7a 54       	r0 = r5 LSHIFT 2;
8420067c:	8a 00       	r0 = rMAC + r0;
8420067e:	92 98       	r0 = M[r0 + 40];
84200680:	1f f2 81 c0 	rMAC = r0 + M[rMAC];
84200684:	92 f0 3d 88 	r0 = M[r7 + 244];
84200688:	8a 04       	r0 = rMAC - r0;
8420068a:	ff fd bc f1 	call (m) 0x37fbe;
8420068e:	35 e9 
84200690:	06 6e       	jump (m) Lc_setup_processing_15;

84200692 <Lc_setup_processing_12>:
            else
            {
                return FALSE;
            }
        }
        else if(op_extra_data->output_buffer[i])
84200692:	1c e8       	r2 = M[r1 + Null];
84200694:	c8 61       	if EQ jump (m) Lc_setup_processing_5;

84200696 <Lc_setup_processing_13>:
                touched_sink |= ( TOUCHED_SINK_0 <<sink_bit );
                touched_src  |=  (TOUCHED_SOURCE_0 << i);
            }
            else
            {
                return FALSE;
84200696:	02 00       	r0 = Null + Null;
84200698:	1b 6e       	jump (m) Lc_setup_processing_18;

8420069a <Lc_setup_processing_14>:
		    {
			    initial_channel_gain = dB60toLinearQ5(op_extra_data->lpvols->channel_trims[i] + op_extra_data->lpvols->master_gain - op_extra_data->post_gain);
			}
			else
			{
				initial_channel_gain = 0;
8420069a:	02 00       	r0 = Null + Null;

8420069c <Lc_setup_processing_15>:
			};

			chan_ptr->chan_idx = i;
8420069c:	37 ee       	M[r4 + Null] = r5;
			chan_ptr->channel_gain = initial_channel_gain;
8420069e:	b2 8f       	M[r4 + 24] = r0;
			chan_ptr->prim_mix_gain = dB60toLinearQ5(0); /*set to 0db. this will be recalculated as part of the update function*/
842006a0:	02 00       	r0 = Null + Null;
842006a2:	ff fd bc f1 	call (m) 0x37fbe;
842006a6:	3d e8 
842006a8:	b2 8e       	M[r4 + 8] = r0;
			chan_ptr->last_volume  = chan_ptr->channel_gain;
842006aa:	b1 89       	rMAC = M[r4 + 24];
842006ac:	f1 8f       	M[r4 + 28] = rMAC;
			chan_ptr++;
842006ae:	36 31       	r4 = r4 + 36;

842006b0 <Lc_setup_processing_16>:
    op_extra_data->cur_mute_gain = 0;
    vol_ctrl_setup_mute(op_extra_data,lpvols->mute);

    /* Link Channels with channel object */
    chan_ptr = op_extra_data->channels;
    for(i=0;i<VOL_CTRL_CONSTANT_NUM_CHANNELS;i++)
842006b0:	7f 20       	r5 = r5 + 1;
842006b2:	20 75       	r6 = r6 + 4;
842006b4:	38 26       	Null = r5 - 8;
842006b6:	da 65       	if NC jump (m) Lc_setup_processing_9;

842006b8 <Lc_setup_processing_17>:
			chan_ptr->last_volume  = chan_ptr->channel_gain;
			chan_ptr++;
        }
    }

    op_extra_data->vol_initialised = 0;
842006b8:	90 f0 bf 8e 	M[r7 + 764] = Null;
    op_extra_data->wait_on_space_buffer=NULL;
842006bc:	90 f0 10 8e 	M[r7 + 64] = Null;
    op_extra_data->wait_on_data_buffer=NULL;
842006c0:	90 f0 11 8e 	M[r7 + 68] = Null;
    op_extra_data->aux_pending = FALSE;
842006c4:	90 f0 bc 8e 	M[r7 + 752] = Null;
    op_extra_data->used_all_input = FALSE;
842006c8:	90 f0 bd 8e 	M[r7 + 756] = Null;

    return TRUE;
842006cc:	42 20       	r0 = Null + 1;

842006ce <Lc_setup_processing_18>:
}
842006ce:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842006d0:	d8 4c       	rts;

842006d2 <$_destroy_processing>:
}

/* ************************************* Data processing-related functions and wrappers **********************************/

void destroy_processing(VOL_CTRL_DATA_T *op_extra_data)
{
842006d2:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842006d4:	16 00       	r4 = r0 + Null;
    timer_cancel_event_atomic(&op_extra_data->pending_timer);
842006d6:	67 f0 f8 22 	r5 = r4 + 760;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
842006da:	ff fd d3 f1 	call (m) 0x3ad3a;
842006de:	21 e3 
    if (*timer_id != TIMER_ID_INVALID)
842006e0:	3a e8       	r0 = M[r5 + Null];
842006e2:	07 60       	if EQ jump (m) Lc_destroy_processing_3;

842006e4 <Lc_destroy_processing_2>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
842006e4:	04 00       	r2 = Null + Null;
842006e6:	03 00       	r1 = Null + Null;
842006e8:	ff fd 2d f0 	call (m) 0x6292;
842006ec:	2b ed 
        *timer_id = TIMER_ID_INVALID;
842006ee:	38 ee       	M[r5 + Null] = Null;

842006f0 <Lc_destroy_processing_3>:
    }
    interrupt_unblock();
842006f0:	ff fd d3 f1 	call (m) 0x3ad56;
842006f4:	27 e3 

    if(!op_extra_data->channels)
842006f6:	b2 b8       	r0 = M[r4 + 104];
842006f8:	05 60       	if EQ jump (m) Lc_destroy_processing_5;

842006fa <Lc_destroy_processing_4>:
    {
        return;
    }

    pfree(op_extra_data->channels);
842006fa:	ff fd 30 f0 	call (m) 0x68d8;
842006fe:	3f ee 
    op_extra_data->channels = NULL;
84200700:	b0 be       	M[r4 + 104] = Null;

84200702 <Lc_destroy_processing_5>:
}
84200702:	f2 48       	popm <FP, r4, r5, rLink>;
84200704:	d8 4c       	rts;

84200706 <$_vol_ctlr_create>:


/* ********************************** API functions ************************************* */

bool vol_ctlr_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200706:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200708:	17 00       	r5 = r0 + Null;
8420070a:	19 09       	r7 = r1 + Null;
8420070c:	20 09       	r6 = r2 + Null;
8420070e:	2a 09       	r8 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200710:	ef fd fe ff 	call (m) 0x4e6;
84200714:	37 ee 
84200716:	16 00       	r4 = r0 + Null;
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(volume_control_wrapper);

    if (!base_op_create(op_data, message_data, response_id, response_data))
84200718:	55 08       	r3 = r8 + Null;
8420071a:	44 08       	r2 = r6 + Null;
8420071c:	4b 08       	r1 = r7 + Null;
8420071e:	3a 00       	r0 = r5 + Null;
84200720:	ef fd fe ff 	call (m) 0x35a;
84200724:	3b e1 
84200726:	10 04       	Null = r0 - Null;
84200728:	03 62       	if NE jump (m) Lc_vol_ctlr_create_3;

8420072a <Lc_vol_ctlr_create_2>:
    {
        return FALSE;
8420072a:	02 00       	r0 = Null + Null;
8420072c:	31 6e       	jump (m) Lc_vol_ctlr_create_7;

8420072e <Lc_vol_ctlr_create_3>:
    }

    /*allocate the volume control shared memory*/
    op_extra_data->shared_volume_ptr = allocate_shared_volume_cntrl();
8420072e:	ff fd 9d f0 	call (m) 0x14256;
84200732:	29 e9 
84200734:	62 f0 63 8e 	M[r4 + 396] = r0;
    if(!op_extra_data->shared_volume_ptr)
84200738:	61 f0 63 88 	rMAC = M[r4 + 396];
8420073c:	08 62       	if NE jump (m) Lc_vol_ctlr_create_6;

8420073e <Lc_vol_ctlr_create_4>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
8420073e:	01 f0 00 60 	rMAC = Null + 4096;
84200742:	a2 f0 00 e8 	r0 = M[r8 + Null];
84200746:	51 8e       	M[r0 + 4] = rMAC;

84200748 <Lc_vol_ctlr_create_5>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
84200748:	42 20       	r0 = Null + 1;
8420074a:	22 6e       	jump (m) Lc_vol_ctlr_create_7;

8420074c <Lc_vol_ctlr_create_6>:
    }

    op_extra_data->lpvols = &op_extra_data->host_vol;
8420074c:	61 f0 f8 20 	rMAC = r4 + 248;
84200750:	61 f0 62 8e 	M[r4 + 392] = rMAC;
    op_extra_data->stream_based = FALSE;
84200754:	60 f0 c3 8e 	M[r4 + 780] = Null;

    /* Initialize mute control */
    op_extra_data->mute_period = 10;
84200758:	81 22       	rMAC = Null + 10;
8420075a:	61 f0 c0 8e 	M[r4 + 768] = rMAC;

    /* Initialize extended data for operator.  Assume initialized to zero*/
    op_extra_data->ReInitFlag = 1;
8420075e:	41 20       	rMAC = Null + 1;
84200760:	61 f0 ac 8e 	M[r4 + 688] = rMAC;

    op_extra_data->pending_timer = TIMER_ID_INVALID;
84200764:	60 f0 be 8e 	M[r4 + 760] = Null;

    if(!cpsInitParameters(&op_extra_data->parms_def,(unsigned*)VOL_CTRL_GetDefaults(base_op_get_cap_id(op_data)),(unsigned*)&op_extra_data->parameters,sizeof(VOL_CTRL_PARAMETERS)))
84200768:	3a 00       	r0 = r5 + Null;
8420076a:	ef fd fe ff 	call (m) 0x4ea;
8420076e:	21 ec 
84200770:	08 f0 2d ef 	call (m) $_VOL_CTRL_GetDefaults;
84200774:	13 00       	r1 = r0 + Null;
84200776:	05 f0 20 41 	r3 = Null + 288;
8420077a:	64 f0 90 21 	r2 = r4 + 400;
8420077e:	62 f0 b4 22 	r0 = r4 + 692;
84200782:	ef fd ff ff 	call (m) 0x742;
84200786:	21 ee 
84200788:	10 04       	Null = r0 - Null;
8420078a:	df 63       	if NE jump (m) Lc_vol_ctlr_create_5;

8420078c <Lc__ite_11>:
8420078c:	d9 6f       	jump (m) Lc_vol_ctlr_create_4;

8420078e <Lc_vol_ctlr_create_7>:
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    return TRUE;
}
8420078e:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200790:	d8 4c       	rts;

84200792 <$_vol_ctlr_destroy>:



bool vol_ctlr_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200792:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200794:	17 00       	r5 = r0 + Null;
84200796:	1a 09       	r8 = r1 + Null;
84200798:	21 09       	r7 = r2 + Null;
8420079a:	2e 00       	r4 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
8420079c:	ef fd fe ff 	call (m) 0x4e6;
842007a0:	2b ea 
842007a2:	10 09       	r6 = r0 + Null;

bool vol_ctlr_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    if (opmgr_op_is_running(op_data))
842007a4:	3a 00       	r0 = r5 + Null;
842007a6:	ff fd 27 f0 	call (m) 0x5700;
842007aa:	3b ea 
842007ac:	10 04       	Null = r0 - Null;
842007ae:	09 60       	if EQ jump (m) Lc_vol_ctlr_destroy_3;

842007b0 <Lc_vol_ctlr_destroy_2>:
    {
        /* We can't destroy a running operator. */
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
842007b0:	03 f0 00 60 	r1 = Null + 4096;
842007b4:	34 00       	r2 = r4 + Null;
842007b6:	3a 00       	r0 = r5 + Null;
842007b8:	ef fd fe ff 	call (m) 0x4bc;
842007bc:	25 e8 
842007be:	16 6e       	jump (m) Lc_vol_ctlr_destroy_6;

842007c0 <Lc_vol_ctlr_destroy_3>:
    }

    /* call base_op destroy that creates and fills response message, too */
    if(!base_op_destroy(op_data, message_data, response_id, response_data))
842007c0:	35 00       	r3 = r4 + Null;
842007c2:	4c 08       	r2 = r7 + Null;
842007c4:	53 08       	r1 = r8 + Null;
842007c6:	3a 00       	r0 = r5 + Null;
842007c8:	ef fd fd ff 	call (m) 0x370;
842007cc:	29 ed 
842007ce:	10 04       	Null = r0 - Null;
842007d0:	03 62       	if NE jump (m) Lc_vol_ctlr_destroy_5;

842007d2 <Lc_vol_ctlr_destroy_4>:
    {
        return(FALSE);
842007d2:	02 00       	r0 = Null + Null;
842007d4:	0b 6e       	jump (m) Lc_vol_ctlr_destroy_6;

842007d6 <Lc_vol_ctlr_destroy_5>:
    }

    /*free volume control shared memory*/
    release_shared_volume_cntrl(op_extra_data->shared_volume_ptr);
842007d6:	82 f0 63 88 	r0 = M[r6 + 396];
842007da:	ff fd 9d f0 	call (m) 0x1427a;
842007de:	21 e5 
    op_extra_data->shared_volume_ptr = NULL;
842007e0:	80 f0 63 8e 	M[r6 + 396] = Null;

    /* Release Channels */
    destroy_processing(op_extra_data);
842007e4:	42 08       	r0 = r6 + Null;
842007e6:	76 4f       	call (m) $_destroy_processing;

    return TRUE;
842007e8:	42 20       	r0 = Null + 1;

842007ea <Lc_vol_ctlr_destroy_6>:
}
842007ea:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842007ec:	d8 4c       	rts;

842007ee <$_vol_ctlr_connect>:
    }
    op_extra_data->aux_buff_size = aux_buffer_min_size;
}

bool vol_ctlr_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842007ee:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842007f0:	11 09       	r7 = r0 + Null;
842007f2:	18 09       	r6 = r1 + Null;
842007f4:	2a 09       	r8 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842007f6:	ef fd fe ff 	call (m) 0x4e6;
842007fa:	31 e7 
842007fc:	16 00       	r4 = r0 + Null;
}

bool vol_ctlr_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_CONNECT_TERMINAL_ID(message_data);    /* extract the terminal_id */
842007fe:	87 f0 00 e8 	r5 = M[r6 + Null];
    tCbuffer* pterminal_buf = OPMGR_GET_OP_CONNECT_BUFFER(message_data);
84200802:	88 f0 01 88 	r6 = M[r6 + 4];

    /* Setup Response to Connection Request. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84200806:	03 00       	r1 = Null + Null;
84200808:	54 08       	r2 = r8 + Null;
8420080a:	4a 08       	r0 = r7 + Null;
8420080c:	ef fd fe ff 	call (m) 0x4bc;
84200810:	31 e5 
84200812:	10 04       	Null = r0 - Null;
84200814:	03 62       	if NE jump (m) Lc_vol_ctlr_connect_3;

84200816 <Lc_vol_ctlr_connect_2>:
    {
        return FALSE;
84200816:	02 00       	r0 = Null + Null;
84200818:	67 6e       	jump (m) Lc_vol_ctlr_connect_23;

8420081a <Lc_vol_ctlr_connect_3>:
    }

    /* (i)  check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources .  */
    /* (ii) check if we are connecting to the right type . It has to be a buffer pointer and not endpoint connection */
    if( !base_op_is_terminal_valid(op_data, terminal_id) || !pterminal_buf)
8420081a:	3b 00       	r1 = r5 + Null;
8420081c:	4a 08       	r0 = r7 + Null;
8420081e:	ef fd fe ff 	call (m) 0x496;
84200822:	39 e3 
84200824:	10 04       	Null = r0 - Null;
84200826:	04 60       	if EQ jump (m) Lc_vol_ctlr_connect_5;

84200828 <Lc_vol_ctlr_connect_4>:
84200828:	0f f8 00 c2 	Null = r6 - Null;
8420082c:	07 62       	if NE jump (m) Lc_vol_ctlr_connect_6;

8420082e <Lc_vol_ctlr_connect_5>:
8420082e:	01 f0 00 60 	rMAC = Null + 4096;
84200832:	a2 f0 00 e8 	r0 = M[r8 + Null];
84200836:	51 8e       	M[r0 + 4] = rMAC;
84200838:	47 6e       	jump (m) Lc_vol_ctlr_connect_19;

8420083a <Lc_vol_ctlr_connect_6>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    if (opmgr_op_is_running(op_data))
8420083a:	4a 08       	r0 = r7 + Null;
8420083c:	ff fd 27 f0 	call (m) 0x5700;
84200840:	25 e6 
84200842:	10 04       	Null = r0 - Null;
84200844:	07 60       	if EQ jump (m) Lc_vol_ctlr_connect_9;

84200846 <Lc_vol_ctlr_connect_7>:
    {
        /* Only Auxiliary Terminals Can be Altered while running */
        if(!(terminal_id & TERMINAL_SINK_MASK) || !(terminal_id&0x1))
84200846:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
8420084a:	00 00 
8420084c:	f1 61       	if EQ jump (m) Lc_vol_ctlr_connect_5;

8420084e <Lc_vol_ctlr_connect_8>:
8420084e:	39 c0       	rMAC = r5 AND 0x1;
84200850:	ef 61       	if EQ jump (m) Lc_vol_ctlr_connect_5;

84200852 <Lc_vol_ctlr_connect_9>:
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
        }
    }

    if(terminal_id&TERMINAL_SINK_MASK)
84200852:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
84200856:	00 00 
84200858:	39 60       	if EQ jump (m) Lc_vol_ctlr_connect_20;

8420085a <Lc_vol_ctlr_connect_10>:
    {
        unsigned term_idx = (terminal_id&TERMINAL_NUM_MASK)>>1;
8420085a:	3a 50       	r0 = r5 LSHIFT -1;
8420085c:	2a f0 1f 00 	r8 = r0 AND 0x1f;

        if(terminal_id&0x1)
84200860:	39 c0       	rMAC = r5 AND 0x1;
84200862:	23 60       	if EQ jump (m) Lc_vol_ctlr_connect_15;

84200864 <Lc_vol_ctlr_connect_11>:
        {
            opmgr_op_suspend_processing(op_data);
84200864:	4a 08       	r0 = r7 + Null;
84200866:	ff fd 27 f0 	call (m) 0x570c;
8420086a:	27 e5 
            op_extra_data->aux_connected |= (1<<term_idx);
8420086c:	51 08       	rMAC = r8 + Null;
8420086e:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84200872:	61 f0 b7 88 	rMAC = M[r4 + 732];
84200876:	89 12       	rMAC = rMAC OR r0;
84200878:	61 f0 b7 8e 	M[r4 + 732] = rMAC;
            op_extra_data->aux_channel[term_idx].buffer = pterminal_buf;
8420087c:	02 fa d2 c8 	r0 = r8 LSHIFT 4;
84200880:	31 00       	rMAC = r4 + Null;
84200882:	51 00       	rMAC = r0 + rMAC;
84200884:	17 f0 6c 20 	r5 = rMAC + 108;
84200888:	78 f0 00 ee 	M[r5 + Null] = r6;
            opmgr_op_resume_processing(op_data);
8420088c:	4a 08       	r0 = r7 + Null;
8420088e:	ff fd 27 f0 	call (m) 0x573a;
84200892:	2d e5 
#ifdef INSTALL_METADATA
            if(op_extra_data->metadata_aux_channel == NULL)
84200894:	31 a9       	rMAC = M[r4 + 80];
84200896:	05 62       	if NE jump (m) Lc_vol_ctlr_connect_14;

84200898 <Lc_vol_ctlr_connect_12>:
            {
                if (buff_has_metadata(op_extra_data->aux_channel[term_idx].buffer))
84200898:	39 e8       	rMAC = M[r5 + Null];
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(tCbuffer *buff)
{
    if (buff->metadata != NULL)
8420089a:	89 89       	rMAC = M[rMAC + 24];
8420089c:	02 60       	if EQ jump (m) Lc_vol_ctlr_connect_14;

8420089e <Lc_vol_ctlr_connect_13>:
                {
                    op_extra_data->metadata_aux_channel = &op_extra_data->aux_channel[term_idx];
8420089e:	37 af       	M[r4 + 80] = r5;

842008a0 <Lc_vol_ctlr_connect_14>:
                }
            }
#endif /* INSTALL_METADATA */
            vol_ctrl_recalc_aux_buffer_size(op_extra_data);
842008a0:	32 00       	r0 = r4 + Null;
842008a2:	06 f0 3d e4 	call (m) Lc_vol_ctrl_recalc_aux_buffer_size_1;
842008a6:	10 6e       	jump (m) Lc_vol_ctlr_connect_19;

842008a8 <Lc_vol_ctlr_connect_15>:
        }
        else
        {
            op_extra_data->input_buffer[term_idx] = pterminal_buf;
842008a8:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
842008ac:	68 f0 02 ee 	M[r4 + r0] = r6;
#ifdef INSTALL_METADATA
            if(op_extra_data->metadata_ip_buffer == NULL)
842008b0:	b1 a8       	rMAC = M[r4 + 72];
842008b2:	06 62       	if NE jump (m) Lc_vol_ctlr_connect_18;

842008b4 <Lc_vol_ctlr_connect_16>:
842008b4:	81 f0 06 88 	rMAC = M[r6 + 24];
842008b8:	03 60       	if EQ jump (m) Lc_vol_ctlr_connect_18;

842008ba <Lc_vol_ctlr_connect_17>:
            {
                if (buff_has_metadata(op_extra_data->input_buffer[term_idx]))
                {
                    op_extra_data->metadata_ip_buffer = op_extra_data->input_buffer[term_idx];
842008ba:	68 f0 12 8e 	M[r4 + 72] = r6;

842008be <Lc_vol_ctlr_connect_18>:
            {
                op_extra_data->metadata_op_buffer = op_extra_data->output_buffer[term_idx];
            }
        }
#endif /* INSTALL_METADATA */
        vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
842008be:	3b 00       	r1 = r5 + Null;
842008c0:	32 00       	r0 = r4 + Null;
842008c2:	06 f0 3b e3 	call (m) Lc_vol_ctrl_recalc_main_buffer_size_1;

842008c6 <Lc_vol_ctlr_connect_19>:
    /* (i)  check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources .  */
    /* (ii) check if we are connecting to the right type . It has to be a buffer pointer and not endpoint connection */
    if( !base_op_is_terminal_valid(op_data, terminal_id) || !pterminal_buf)
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
842008c6:	42 20       	r0 = Null + 1;
842008c8:	0f 6e       	jump (m) Lc_vol_ctlr_connect_23;

842008ca <Lc_vol_ctlr_connect_20>:
            vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
        }
    }
    else
    {
        unsigned term_idx = terminal_id&TERMINAL_NUM_MASK;
842008ca:	ba c2       	r0 = r5 AND 0x3f;
        op_extra_data->output_buffer[term_idx] = pterminal_buf;
842008cc:	52 54       	r0 = r0 LSHIFT 2;
842008ce:	31 00       	rMAC = r4 + Null;
842008d0:	51 00       	rMAC = r0 + rMAC;
842008d2:	18 f0 08 8e 	M[rMAC + 32] = r6;
#ifdef INSTALL_METADATA
        if(op_extra_data->metadata_op_buffer == NULL)
842008d6:	f1 a8       	rMAC = M[r4 + 76];
842008d8:	f3 63       	if NE jump (m) Lc_vol_ctlr_connect_18;

842008da <Lc_vol_ctlr_connect_21>:
842008da:	81 f0 06 88 	rMAC = M[r6 + 24];
842008de:	f0 61       	if EQ jump (m) Lc_vol_ctlr_connect_18;

842008e0 <Lc_vol_ctlr_connect_22>:
        {
            if (buff_has_metadata(op_extra_data->output_buffer[term_idx]))
            {
                op_extra_data->metadata_op_buffer = op_extra_data->output_buffer[term_idx];
842008e0:	68 f0 13 8e 	M[r4 + 76] = r6;
842008e4:	ed 6f       	jump (m) Lc_vol_ctlr_connect_18;

842008e6 <Lc_vol_ctlr_connect_23>:
        }
#endif /* INSTALL_METADATA */
        vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
    }
    return TRUE;
}
842008e6:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842008e8:	d8 4c       	rts;

842008ea <$_vol_ctlr_disconnect>:

bool vol_ctlr_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842008ea:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842008ec:	10 09       	r6 = r0 + Null;
842008ee:	1f 00       	r5 = r1 + Null;
842008f0:	29 09       	r7 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842008f2:	ef fd fd ff 	call (m) 0x4e6;
842008f6:	35 ef 
842008f8:	16 00       	r4 = r0 + Null;
}

bool vol_ctlr_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_DISCONNECT_TERMINAL_ID(message_data);
842008fa:	3f e8       	r5 = M[r5 + Null];

    /* Setup Response to Disconnection Request. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
842008fc:	03 00       	r1 = Null + Null;
842008fe:	4c 08       	r2 = r7 + Null;
84200900:	42 08       	r0 = r6 + Null;
84200902:	ef fd fd ff 	call (m) 0x4bc;
84200906:	3b ed 
84200908:	10 04       	Null = r0 - Null;
8420090a:	03 62       	if NE jump (m) Lc_vol_ctlr_disconnect_3;

8420090c <Lc_vol_ctlr_disconnect_2>:
    {
        return FALSE;
8420090c:	02 00       	r0 = Null + Null;
8420090e:	92 6e       	jump (m) Lc_vol_ctlr_disconnect_39;

84200910 <Lc_vol_ctlr_disconnect_3>:
    }

    /* (i)  check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources .  */
    /* (ii) check if we are connecting to the right type . It has to be a buffer pointer and not endpoint connection */
    if( !base_op_is_terminal_valid(op_data, terminal_id))
84200910:	3b 00       	r1 = r5 + Null;
84200912:	42 08       	r0 = r6 + Null;
84200914:	ef fd fd ff 	call (m) 0x496;
84200918:	23 ec 
8420091a:	10 04       	Null = r0 - Null;
8420091c:	08 62       	if NE jump (m) Lc_vol_ctlr_disconnect_6;

8420091e <Lc_vol_ctlr_disconnect_4>:
8420091e:	01 f0 00 60 	rMAC = Null + 4096;
84200922:	92 f0 00 e8 	r0 = M[r7 + Null];
84200926:	51 8e       	M[r0 + 4] = rMAC;

84200928 <Lc_vol_ctlr_disconnect_5>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
84200928:	42 20       	r0 = Null + 1;
8420092a:	84 6e       	jump (m) Lc_vol_ctlr_disconnect_39;

8420092c <Lc_vol_ctlr_disconnect_6>:
    }

    if (opmgr_op_is_running(op_data))
8420092c:	42 08       	r0 = r6 + Null;
8420092e:	ff fd 26 f0 	call (m) 0x5700;
84200932:	33 ee 
84200934:	10 04       	Null = r0 - Null;
84200936:	07 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_9;

84200938 <Lc_vol_ctlr_disconnect_7>:
    {
        /* Only Auxiliary Terminals Can be Altered while running */
        if(!(terminal_id & TERMINAL_SINK_MASK) || !(terminal_id&0x1))
84200938:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
8420093c:	00 00 
8420093e:	f0 61       	if EQ jump (m) Lc_vol_ctlr_disconnect_4;

84200940 <Lc_vol_ctlr_disconnect_8>:
84200940:	39 c0       	rMAC = r5 AND 0x1;
84200942:	ee 61       	if EQ jump (m) Lc_vol_ctlr_disconnect_4;

84200944 <Lc_vol_ctlr_disconnect_9>:
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
        }
    }

    if(terminal_id&TERMINAL_SINK_MASK)
84200944:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
84200948:	00 00 
8420094a:	50 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_28;

8420094c <Lc_vol_ctlr_disconnect_10>:
    {
        unsigned term_idx = (terminal_id&TERMINAL_NUM_MASK)>>1;
8420094c:	3a 50       	r0 = r5 LSHIFT -1;
8420094e:	29 f0 1f 00 	r7 = r0 AND 0x1f;

        if(terminal_id&0x1)
84200952:	39 c0       	rMAC = r5 AND 0x1;
84200954:	2f 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_19;

84200956 <Lc_vol_ctlr_disconnect_11>:
        {
#ifdef INSTALL_METADATA
            if (op_extra_data->metadata_aux_channel == &op_extra_data->aux_channel[term_idx])
84200956:	02 f9 d2 c8 	r0 = r7 LSHIFT 4;
8420095a:	31 00       	rMAC = r4 + Null;
8420095c:	51 00       	rMAC = r0 + rMAC;
8420095e:	17 f0 6c 20 	r5 = rMAC + 108;
84200962:	31 a9       	rMAC = M[r4 + 80];
84200964:	c8 05       	Null = rMAC - r5;
84200966:	10 62       	if NE jump (m) Lc_vol_ctlr_disconnect_18;

84200968 <Lc_vol_ctlr_disconnect_12>:
            {
                unsigned i;
                bool found_alternative = FALSE;
                vol_ctrl_aux_channel_t *aux_chan = NULL;
                for (i = 0, aux_chan = &op_extra_data->aux_channel[0];
84200968:	01 00       	rMAC = Null + Null;
8420096a:	62 f0 6c 20 	r0 = r4 + 108;

8420096e <Lc_vol_ctlr_disconnect_13>:
                     i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
                     i++, aux_chan++)
                {
                    if (i == term_idx)
8420096e:	9f f1 00 c2 	Null = rMAC - r7;
84200972:	05 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_16;

84200974 <Lc_vol_ctlr_disconnect_14>:
                    {
                        continue;
                    }
                    if (aux_chan->buffer != NULL && buff_has_metadata(aux_chan->buffer))
84200974:	13 e8       	r1 = M[r0 + Null];
84200976:	03 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_16;

84200978 <Lc_vol_ctlr_disconnect_15>:
84200978:	9b 89       	r1 = M[r1 + 24];
8420097a:	50 62       	if NE jump (m) Lc_vol_ctlr_disconnect_36;

8420097c <Lc_vol_ctlr_disconnect_16>:
                unsigned i;
                bool found_alternative = FALSE;
                vol_ctrl_aux_channel_t *aux_chan = NULL;
                for (i = 0, aux_chan = &op_extra_data->aux_channel[0];
                     i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
                     i++, aux_chan++)
8420097c:	49 20       	rMAC = rMAC + 1;
8420097e:	12 28       	r0 = r0 + 16;
            {
                unsigned i;
                bool found_alternative = FALSE;
                vol_ctrl_aux_channel_t *aux_chan = NULL;
                for (i = 0, aux_chan = &op_extra_data->aux_channel[0];
                     i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
84200980:	08 26       	Null = rMAC - 8;
84200982:	f6 65       	if NC jump (m) Lc_vol_ctlr_disconnect_13;

84200984 <Lc_vol_ctlr_disconnect_17>:
                        break;
                    }
                }
                if (!found_alternative)
                {
                    op_extra_data->metadata_aux_channel = NULL;
84200984:	30 af       	M[r4 + 80] = Null;

84200986 <Lc_vol_ctlr_disconnect_18>:
                }
            }
#endif /* INSTALL_METADATA */
            opmgr_op_suspend_processing(op_data);
84200986:	42 08       	r0 = r6 + Null;
84200988:	ff fd 26 f0 	call (m) 0x570c;
8420098c:	25 ec 
            op_extra_data->aux_connected &= ~(1<<term_idx);
8420098e:	00 f9 92 de 	r0 = 0x1 LSHIFT r7;
84200992:	ff f2 51 d6 	rMAC = -1 - r0;
84200996:	62 f0 b7 88 	r0 = M[r4 + 732];
8420099a:	89 10       	rMAC = rMAC AND r0;
8420099c:	61 f0 b7 8e 	M[r4 + 732] = rMAC;
            op_extra_data->aux_channel[term_idx].buffer = NULL;
842009a0:	38 ee       	M[r5 + Null] = Null;
            opmgr_op_resume_processing(op_data);
842009a2:	42 08       	r0 = r6 + Null;
842009a4:	ff fd 26 f0 	call (m) 0x573a;
842009a8:	37 ec 
            vol_ctrl_recalc_aux_buffer_size(op_extra_data);
842009aa:	32 00       	r0 = r4 + Null;
842009ac:	05 f0 33 ec 	call (m) Lc_vol_ctrl_recalc_aux_buffer_size_1;
842009b0:	bc 6f       	jump (m) Lc_vol_ctlr_disconnect_5;

842009b2 <Lc_vol_ctlr_disconnect_19>:
        }
        else
        {
#ifdef INSTALL_METADATA
            if (op_extra_data->metadata_ip_buffer == op_extra_data->input_buffer[term_idx])
842009b2:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
842009b6:	31 00       	rMAC = r4 + Null;
842009b8:	51 00       	rMAC = r0 + rMAC;
842009ba:	b2 a8       	r0 = M[r4 + 72];
842009bc:	0b e8       	r1 = M[rMAC + Null];
842009be:	d0 04       	Null = r0 - r1;
842009c0:	0f 62       	if NE jump (m) Lc_vol_ctlr_disconnect_26;

842009c2 <Lc_vol_ctlr_disconnect_20>:
            {
                unsigned i;
                bool found_alternative = FALSE;
                for (i = 0; i < VOL_CTRL_CONSTANT_NUM_CHANNELS; i++)
842009c2:	03 00       	r1 = Null + Null;
842009c4:	32 00       	r0 = r4 + Null;

842009c6 <Lc_vol_ctlr_disconnect_21>:
                {
                    if (i == term_idx)
842009c6:	9f f3 00 c2 	Null = r1 - r7;
842009ca:	05 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_24;

842009cc <Lc_vol_ctlr_disconnect_22>:
                    {
                        continue;
                    }
                    if (op_extra_data->input_buffer[i] != NULL && buff_has_metadata(op_extra_data->input_buffer[i]))
842009cc:	14 e8       	r2 = M[r0 + Null];
842009ce:	03 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_24;

842009d0 <Lc_vol_ctlr_disconnect_23>:
842009d0:	a4 89       	r2 = M[r2 + 24];
842009d2:	26 62       	if NE jump (m) Lc_vol_ctlr_disconnect_37;

842009d4 <Lc_vol_ctlr_disconnect_24>:
#ifdef INSTALL_METADATA
            if (op_extra_data->metadata_ip_buffer == op_extra_data->input_buffer[term_idx])
            {
                unsigned i;
                bool found_alternative = FALSE;
                for (i = 0; i < VOL_CTRL_CONSTANT_NUM_CHANNELS; i++)
842009d4:	5b 20       	r1 = r1 + 1;
842009d6:	12 21       	r0 = r0 + 4;
842009d8:	18 26       	Null = r1 - 8;
842009da:	f6 65       	if NC jump (m) Lc_vol_ctlr_disconnect_21;

842009dc <Lc_vol_ctlr_disconnect_25>:
                        break;
                    }
                }
                if (!found_alternative)
                {
                    op_extra_data->metadata_ip_buffer = NULL;
842009dc:	b0 ae       	M[r4 + 72] = Null;

842009de <Lc_vol_ctlr_disconnect_26>:
                }
            }
#endif /* INSTALL_METADATA */
            op_extra_data->input_buffer[term_idx] = NULL;
842009de:	08 ee       	M[rMAC + Null] = Null;

842009e0 <Lc_vol_ctlr_disconnect_27>:
                op_extra_data->metadata_op_buffer = NULL;
            }
        }
#endif /* INSTALL_METADATA */
        op_extra_data->output_buffer[term_idx] = NULL;
        vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
842009e0:	3b 00       	r1 = r5 + Null;
842009e2:	32 00       	r0 = r4 + Null;
842009e4:	05 f0 39 ea 	call (m) Lc_vol_ctrl_recalc_main_buffer_size_1;
842009e8:	a0 6f       	jump (m) Lc_vol_ctlr_disconnect_5;

842009ea <Lc_vol_ctlr_disconnect_28>:
            vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
        }
    }
    else
    {
        unsigned term_idx = terminal_id&TERMINAL_NUM_MASK;
842009ea:	ba c2       	r0 = r5 AND 0x3f;
#ifdef INSTALL_METADATA
        if (op_extra_data->metadata_op_buffer == op_extra_data->output_buffer[term_idx])
842009ec:	53 54       	r1 = r0 LSHIFT 2;
842009ee:	31 00       	rMAC = r4 + Null;
842009f0:	59 00       	rMAC = r1 + rMAC;
842009f2:	09 30       	rMAC = rMAC + 32;
842009f4:	f3 a8       	r1 = M[r4 + 76];
842009f6:	0c e8       	r2 = M[rMAC + Null];
842009f8:	18 05       	Null = r1 - r2;
842009fa:	0e 62       	if NE jump (m) Lc_vol_ctlr_disconnect_35;

842009fc <Lc_vol_ctlr_disconnect_29>:
        {
            unsigned i;
            bool found_alternative = FALSE;
            for (i = 0; i < VOL_CTRL_CONSTANT_NUM_CHANNELS; i++)
842009fc:	03 00       	r1 = Null + Null;
842009fe:	34 30       	r2 = r4 + 32;

84200a00 <Lc_vol_ctlr_disconnect_30>:
            {
                if (i == term_idx)
84200a00:	98 04       	Null = r1 - r0;
84200a02:	05 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_33;

84200a04 <Lc_vol_ctlr_disconnect_31>:
                {
                    continue;
                }
                if (op_extra_data->output_buffer[i] != NULL && buff_has_metadata(op_extra_data->output_buffer[i]))
84200a04:	25 e8       	r3 = M[r2 + Null];
84200a06:	03 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_33;

84200a08 <Lc_vol_ctlr_disconnect_32>:
84200a08:	ad 89       	r3 = M[r3 + 24];
84200a0a:	0e 62       	if NE jump (m) Lc_vol_ctlr_disconnect_38;

84200a0c <Lc_vol_ctlr_disconnect_33>:
#ifdef INSTALL_METADATA
        if (op_extra_data->metadata_op_buffer == op_extra_data->output_buffer[term_idx])
        {
            unsigned i;
            bool found_alternative = FALSE;
            for (i = 0; i < VOL_CTRL_CONSTANT_NUM_CHANNELS; i++)
84200a0c:	5b 20       	r1 = r1 + 1;
84200a0e:	24 21       	r2 = r2 + 4;
84200a10:	18 26       	Null = r1 - 8;
84200a12:	f7 65       	if NC jump (m) Lc_vol_ctlr_disconnect_30;

84200a14 <Lc_vol_ctlr_disconnect_34>:
                    break;
                }
            }
            if (!found_alternative)
            {
                op_extra_data->metadata_op_buffer = NULL;
84200a14:	f0 ae       	M[r4 + 76] = Null;

84200a16 <Lc_vol_ctlr_disconnect_35>:
            }
        }
#endif /* INSTALL_METADATA */
        op_extra_data->output_buffer[term_idx] = NULL;
84200a16:	08 ee       	M[rMAC + Null] = Null;
84200a18:	e4 6f       	jump (m) Lc_vol_ctlr_disconnect_27;

84200a1a <Lc_vol_ctlr_disconnect_36>:
                    {
                        continue;
                    }
                    if (aux_chan->buffer != NULL && buff_has_metadata(aux_chan->buffer))
                    {
                        op_extra_data->metadata_aux_channel = aux_chan;
84200a1a:	32 af       	M[r4 + 80] = r0;
                        found_alternative = TRUE;
                        break;
84200a1c:	b5 6f       	jump (m) Lc_vol_ctlr_disconnect_18;

84200a1e <Lc_vol_ctlr_disconnect_37>:
                    {
                        continue;
                    }
                    if (op_extra_data->input_buffer[i] != NULL && buff_has_metadata(op_extra_data->input_buffer[i]))
                    {
                        op_extra_data->metadata_ip_buffer = op_extra_data->input_buffer[i];
84200a1e:	5a 54       	r0 = r1 LSHIFT 2;
84200a20:	b2 e8       	r0 = M[r4 + r0];
84200a22:	b2 ae       	M[r4 + 72] = r0;
                        found_alternative = TRUE;
                        break;
84200a24:	dd 6f       	jump (m) Lc_vol_ctlr_disconnect_26;

84200a26 <Lc_vol_ctlr_disconnect_38>:
                {
                    continue;
                }
                if (op_extra_data->output_buffer[i] != NULL && buff_has_metadata(op_extra_data->output_buffer[i]))
                {
                    op_extra_data->metadata_op_buffer = op_extra_data->output_buffer[i];
84200a26:	5b 54       	r1 = r1 LSHIFT 2;
84200a28:	32 00       	r0 = r4 + Null;
84200a2a:	9a 00       	r0 = r1 + r0;
84200a2c:	12 98       	r0 = M[r0 + 32];
84200a2e:	f2 ae       	M[r4 + 76] = r0;
                    found_alternative = TRUE;
                    break;
84200a30:	f3 6f       	jump (m) Lc_vol_ctlr_disconnect_35;

84200a32 <Lc_vol_ctlr_disconnect_39>:
        op_extra_data->output_buffer[term_idx] = NULL;
        vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
    }

    return TRUE;
}
84200a32:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200a34:	d8 4c       	rts;

84200a36 <$_vol_ctlr_start>:

bool vol_ctlr_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200a36:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200a38:	17 00       	r5 = r0 + Null;
84200a3a:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200a3c:	ef fd fd ff 	call (m) 0x4e6;
84200a40:	2b e5 
84200a42:	16 00       	r4 = r0 + Null;

bool vol_ctlr_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    /* Setup Response to Start Request.   Assume Failure*/
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84200a44:	03 00       	r1 = Null + Null;
84200a46:	44 08       	r2 = r6 + Null;
84200a48:	3a 00       	r0 = r5 + Null;
84200a4a:	ef fd fd ff 	call (m) 0x4bc;
84200a4e:	33 e3 
84200a50:	10 04       	Null = r0 - Null;
84200a52:	03 62       	if NE jump (m) Lc_vol_ctlr_start_3;

84200a54 <Lc_vol_ctlr_start_2>:
    {
        return FALSE;
84200a54:	02 00       	r0 = Null + Null;
84200a56:	3b 6e       	jump (m) Lc_vol_ctlr_start_11;

84200a58 <Lc_vol_ctlr_start_3>:
    }

    if (opmgr_op_is_running(op_data))
84200a58:	3a 00       	r0 = r5 + Null;
84200a5a:	ff fd 26 f0 	call (m) 0x5700;
84200a5e:	27 e5 
84200a60:	10 04       	Null = r0 - Null;
84200a62:	34 62       	if NE jump (m) Lc_vol_ctlr_start_10;

84200a64 <Lc_vol_ctlr_start_4>:
    {
        return TRUE;
    }

    if (!setup_processing(op_extra_data))
84200a64:	32 00       	r0 = r4 + Null;
84200a66:	fd ff 2b ec 	call (m) .L0;
84200a6a:	10 04       	Null = r0 - Null;
84200a6c:	06 62       	if NE jump (m) Lc_vol_ctlr_start_6;

84200a6e <Lc_vol_ctlr_start_5>:
84200a6e:	01 f0 00 60 	rMAC = Null + 4096;
84200a72:	82 f0 00 e8 	r0 = M[r6 + Null];
84200a76:	51 8e       	M[r0 + 4] = rMAC;

84200a78 <Lc_vol_ctlr_start_6>:
     *
     * User can set that via DOWNSTREAM_LATENCY_EST parameter, if hasn't
     * been set by the user we will find a suitable value.
     */
    op_extra_data->downstream_latency_estimate =
        VOL_CTRL_DOWNSTREAM_LATENCY_EST(op_extra_data)*MILLISECOND;
84200a78:	61 f0 d2 88 	rMAC = M[r4 + 840];
84200a7c:	03 f0 e8 f1 	rMAC = rMAC * 1000 (int);
84200a80:	91 d9 
    if(0 == op_extra_data->downstream_latency_estimate &&
       NULL != op_extra_data->metadata_op_buffer)
84200a82:	61 f0 d0 8e 	M[r4 + 832] = rMAC;
84200a86:	1a 62       	if NE jump (m) Lc_vol_ctlr_start_9;

84200a88 <Lc_vol_ctlr_start_7>:
84200a88:	f2 a8       	r0 = M[r4 + 76];
84200a8a:	18 60       	if EQ jump (m) Lc_vol_ctlr_start_9;

84200a8c <Lc_vol_ctlr_start_8>:
        /* user hasn't set the parameter, a good achievable latency with the
         * assumption that the operator's output buffer is directly consumed
         * by a timed playback module at the end of chain is 75% of the buffers
         * size plus one system kick period.
         */
        unsigned buf_size = cbuffer_get_size_in_words(op_extra_data->metadata_op_buffer);
84200a8c:	ff fd 9c f0 	call (m) 0x14450;
84200a90:	25 ee 
84200a92:	10 09       	r6 = r0 + Null;
        op_extra_data->downstream_latency_estimate =
            convert_samples_to_time(buf_size, op_extra_data->sample_rate)*3/4 +
            stream_if_get_system_kick_period();
84200a94:	ff fd 3b f0 	call (m) 0x8146;
84200a98:	33 e5 
84200a9a:	17 00       	r5 = r0 + Null;
84200a9c:	63 f0 3b 88 	r1 = M[r4 + 236];
84200aa0:	42 08       	r0 = r6 + Null;
84200aa2:	ff fd bc f0 	call (m) 0x183fe;
84200aa6:	3d ea 
84200aa8:	d2 40       	r0 = r0 * 3 (int);
84200aaa:	13 58       	r1 = r0 ASHIFT -1;
84200aac:	71 f3 d3 c8 	r1 = r1 LSHIFT -30;
84200ab0:	9a 00       	r0 = r1 + r0;
84200ab2:	52 58       	r0 = r0 ASHIFT -2;
84200ab4:	d1 01       	rMAC = r0 + r5;
84200ab6:	61 f0 d0 8e 	M[r4 + 832] = rMAC;

84200aba <Lc_vol_ctlr_start_9>:
    }
    /* Reset timestamp references used for aux TTP*/
    op_extra_data->current_timestamp_valid = FALSE;
84200aba:	60 f0 cd 8e 	M[r4 + 820] = Null;
    op_extra_data->main_timestamp_valid = FALSE;
84200abe:	60 f0 ca 8e 	M[r4 + 808] = Null;
    op_extra_data->prev_consumed_samples = 0;
84200ac2:	60 f0 cf 8e 	M[r4 + 828] = Null;
    op_extra_data->aux0_ttp.generate_ttp = FALSE;
84200ac6:	60 f0 c8 8e 	M[r4 + 800] = Null;

84200aca <Lc_vol_ctlr_start_10>:
        return FALSE;
    }

    if (opmgr_op_is_running(op_data))
    {
        return TRUE;
84200aca:	42 20       	r0 = Null + 1;

84200acc <Lc_vol_ctlr_start_11>:
    op_extra_data->prev_consumed_samples = 0;
    op_extra_data->aux0_ttp.generate_ttp = FALSE;
#endif /* VOLUME_CONTROL_AUX_TTP_SUPPORT */

    return TRUE;
}
84200acc:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200ace:	d8 4c       	rts;

84200ad0 <$_vol_ctlr_buffer_details>:
    return TRUE;
}


bool vol_ctlr_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200ad0:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200ad2:	12 09       	r8 = r0 + Null;
84200ad4:	1e 00       	r4 = r1 + Null;
84200ad6:	23 09       	r9 = r2 + Null;
84200ad8:	2f 00       	r5 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200ada:	ef fd fd ff 	call (m) 0x4e6;
84200ade:	2d e0 
84200ae0:	10 09       	r6 = r0 + Null;
bool vol_ctlr_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T* opx_data = get_instance_data(op_data);
    OP_BUF_DETAILS_RSP *resp;
    unsigned buffer_size, base_buffer_size;
    unsigned terminal_id = OPMGR_GET_OP_BUF_DETAILS_TERMINAL_ID(message_data);
84200ae2:	69 f0 00 e8 	r7 = M[r4 + Null];
#if !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE)
    unsigned term_idx;
#endif /* !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE) */

    if (!base_op_buffer_details(op_data, message_data, response_id, response_data))
84200ae6:	3d 00       	r3 = r5 + Null;
84200ae8:	5c 08       	r2 = r9 + Null;
84200aea:	33 00       	r1 = r4 + Null;
84200aec:	52 08       	r0 = r8 + Null;
84200aee:	ef fd fc ff 	call (m) 0x37c;
84200af2:	2f e4 
84200af4:	10 04       	Null = r0 - Null;
84200af6:	03 62       	if NE jump (m) Lc_vol_ctlr_buffer_details_3;

84200af8 <Lc_vol_ctlr_buffer_details_2>:
    {
        return FALSE;
84200af8:	02 00       	r0 = Null + Null;
84200afa:	8e 6e       	jump (m) Lc_vol_ctlr_buffer_details_29;

84200afc <Lc_vol_ctlr_buffer_details_3>:
    }

    resp = (OP_BUF_DETAILS_RSP*)*response_data;
84200afc:	3e e8       	r4 = M[r5 + Null];
    base_buffer_size = resp->b.buffer_size + VOL_CTRL_BUFFER_SIZE_PROVISION;
84200afe:	31 89       	rMAC = M[r4 + 16];
84200b00:	89 21       	rMAC = rMAC + 6;
        /* If an input/output connection is already present and has metadata then
         * we are obliged to return that buffer so that metadata can be shared
         * between channels. */
        tCbuffer *meta_buff;

        if ((terminal_id & TERMINAL_SINK_MASK) == TERMINAL_SINK_MASK)
84200b02:	40 f0 92 f0 	r0 = r7 AND 0x800000;
84200b06:	00 00 
84200b08:	5f 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_23;

84200b0a <Lc_vol_ctlr_buffer_details_4>:
        {
            /* Only the main input channels consume metadata, the aux inputs do not */
            if ((terminal_id & 0x1) == 0)
84200b0a:	92 f0 01 00 	r0 = r7 AND 0x1;
84200b0e:	04 62       	if NE jump (m) Lc_vol_ctlr_buffer_details_6;

84200b10 <Lc_vol_ctlr_buffer_details_5>:
            {
                meta_buff = opx_data->metadata_ip_buffer;
84200b10:	82 f0 12 88 	r0 = M[r6 + 72];
84200b14:	07 6e       	jump (m) Lc_vol_ctlr_buffer_details_9;

84200b16 <Lc_vol_ctlr_buffer_details_6>:
                resp->supports_metadata = TRUE;
            }
            else
            {
                if(NULL != opx_data->metadata_aux_channel)
84200b16:	82 f0 14 88 	r0 = M[r6 + 80];
84200b1a:	03 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_8;

84200b1c <Lc_vol_ctlr_buffer_details_7>:
                {
                    meta_buff = opx_data->metadata_aux_channel->buffer;
84200b1c:	12 e8       	r0 = M[r0 + Null];
84200b1e:	02 6e       	jump (m) Lc_vol_ctlr_buffer_details_9;

84200b20 <Lc_vol_ctlr_buffer_details_8>:
                }
                else
                {
                    meta_buff = NULL;
84200b20:	02 00       	r0 = Null + Null;

84200b22 <Lc_vol_ctlr_buffer_details_9>:
            }
        }
        else
        {
            meta_buff = opx_data->metadata_op_buffer;
            resp->supports_metadata = TRUE;
84200b22:	33 92       	r1 = MBU[r4 + 8];
84200b24:	33 ff ef 1f 	r1 = r1 AND 0xffffffef;
84200b28:	db c9       	r1 = r1 OR 0x10;
84200b2a:	33 9a       	MB[r4 + 8] = r1;
        }

        resp->metadata_buffer = meta_buff;
84200b2c:	f2 8e       	M[r4 + 12] = r0;

    }
#endif /* INSTALL_METADATA */

    /* buffer size of 2.5ms worth at the sample rate of the operator */
    buffer_size = frac_mult(opx_data->sample_rate,FRACTIONAL(0.0025));
84200b2e:	82 f0 3b 88 	r0 = M[r6 + 236];
84200b32:	05 f0 f3 f0 	r1 = Null + 5368709;
84200b36:	85 53 
84200b38:	3f f2 47 c9 	r5 = r0 * r1 (frac);

    if (buffer_size==0)
84200b3c:	38 04       	Null = r5 - Null;
84200b3e:	03 62       	if NE jump (m) Lc_vol_ctlr_buffer_details_11;

84200b40 <Lc_vol_ctlr_buffer_details_10>:
    {
        buffer_size = VOL_CTRL_BUFFER_SIZE;
84200b40:	07 f0 80 40 	r5 = Null + 128;

84200b44 <Lc_vol_ctlr_buffer_details_11>:
    }

    if (buffer_size < base_buffer_size)
84200b44:	78 04       	Null = r5 - rMAC;
84200b46:	02 f0 87 e0 	if C jump (m) Lc_vol_ctlr_buffer_details_13;

84200b4a <Lc_vol_ctlr_buffer_details_12>:
    {
        buffer_size = base_buffer_size;
84200b4a:	0f 00       	r5 = rMAC + Null;

84200b4c <Lc_vol_ctlr_buffer_details_13>:
    }

#if !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE)
    if(terminal_id&TERMINAL_SINK_MASK)
84200b4c:	40 f0 91 f0 	rMAC = r7 AND 0x800000;
84200b50:	00 00 
84200b52:	47 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_25;

84200b54 <Lc_vol_ctlr_buffer_details_14>:
    {
        if(terminal_id&0x1)
84200b54:	91 f0 01 00 	rMAC = r7 AND 0x1;
84200b58:	3a 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_24;

84200b5a <Lc_vol_ctlr_buffer_details_15>:
            unsigned aux_min_size, main_buff_size = 0;

            /* Aux input : If we have a main input connected, 
             * try to make sure the aux buffer is at least as big
             */
            if (opx_data->metadata_ip_buffer != NULL)
84200b5a:	82 f0 12 88 	r0 = M[r6 + 72];
84200b5e:	08 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_18;

84200b60 <Lc_vol_ctlr_buffer_details_16>:
            {
                main_buff_size = cbuffer_get_size_in_words(opx_data->metadata_ip_buffer);
84200b60:	ff fd 9c f0 	call (m) 0x14450;
84200b64:	31 e7 
            }

            if (buffer_size < main_buff_size)
84200b66:	b8 04       	Null = r5 - r0;
84200b68:	02 f0 87 e0 	if C jump (m) Lc_vol_ctlr_buffer_details_18;

84200b6c <Lc_vol_ctlr_buffer_details_17>:
            {
                buffer_size = main_buff_size;
84200b6c:	17 00       	r5 = r0 + Null;

84200b6e <Lc_vol_ctlr_buffer_details_18>:
            }

            /* Aux buffer should be at least 2 kick periods at the system sample rate */
            aux_min_size = 2 * (uint32)(((uint64)stream_if_get_system_kick_period() 
                * opx_data->sample_rate) / SECOND);
84200b6e:	ff fd 3a f0 	call (m) 0x8146;
84200b72:	39 ee 
84200b74:	84 f0 3b 88 	r2 = M[r6 + 236];
84200b78:	93 5b       	r1 = r0 ASHIFT -31;
84200b7a:	05 00       	r3 = Null + Null;
84200b7c:	3f f4 01 cc 	rMAC = r2 * r1 (UU);
84200b80:	c9 57       	rMAC = rMAC LSHIFT 32 (56bit);
84200b82:	2f f4 01 ca 	rMAC = rMAC + r2 * r0 (UU);
84200b86:	09 50       	rMAC = rMAC LSHIFT -1 (56bit);
84200b88:	00 f0 a4 f7 	r2 = Null + 1000000;
84200b8c:	40 42 
84200b8e:	00 f1 d3 c8 	r1 = rMAC LSHIFT 0;
84200b92:	ca 57       	r0 = rMAC LSHIFT 32;
84200b94:	ff fd cb f0 	call (m) 0x1a208;
84200b98:	35 e3 
84200b9a:	12 54       	r0 = r0 LSHIFT 1;
            
            if (buffer_size < aux_min_size)
84200b9c:	b8 04       	Null = r5 - r0;
84200b9e:	02 f0 87 e0 	if C jump (m) Lc_vol_ctlr_buffer_details_20;

84200ba2 <Lc_vol_ctlr_buffer_details_19>:
            {
                buffer_size = aux_min_size;
84200ba2:	17 00       	r5 = r0 + Null;

84200ba4 <Lc_vol_ctlr_buffer_details_20>:
            }

            /* Configured size overrides. */
            if (opx_data->aux_buffer_size_cfg != 0)
84200ba4:	81 f0 d4 88 	rMAC = M[r6 + 848];
84200ba8:	02 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_22;

84200baa <Lc_vol_ctlr_buffer_details_21>:
            {
                buffer_size = opx_data->aux_buffer_size_cfg;
84200baa:	0f 00       	r5 = rMAC + Null;

84200bac <Lc_vol_ctlr_buffer_details_22>:
            }

            /* Don't run in place on the aux inputs. */
            resp->runs_in_place = FALSE;
84200bac:	31 92       	rMAC = MBU[r4 + 8];
84200bae:	11 ff f7 1f 	rMAC = rMAC AND 0xfffffff7;
84200bb2:	31 9a       	MB[r4 + 8] = rMAC;

            /* Set the asked buffer size. */
            resp->b.buffer_size = buffer_size;
84200bb4:	37 8f       	M[r4 + 16] = r5;
            opx_data->aux_buff_size = buffer_size;
84200bb6:	87 f0 bb 8e 	M[r6 + 748] = r5;

            return vol_ctrl_fixup_buffer_details(opx_data, terminal_id, resp);
84200bba:	34 00       	r2 = r4 + Null;
84200bbc:	4b 08       	r1 = r7 + Null;
84200bbe:	42 08       	r0 = r6 + Null;
84200bc0:	04 f0 39 eb 	call (m) Lc_vol_ctrl_fixup_buffer_details_1;
84200bc4:	29 6e       	jump (m) Lc_vol_ctlr_buffer_details_29;

84200bc6 <Lc_vol_ctlr_buffer_details_23>:
                resp->supports_metadata = TRUE;
            }
        }
        else
        {
            meta_buff = opx_data->metadata_op_buffer;
84200bc6:	82 f0 13 88 	r0 = M[r6 + 76];
84200bca:	ac 6f       	jump (m) Lc_vol_ctlr_buffer_details_9;

84200bcc <Lc_vol_ctlr_buffer_details_24>:

            return vol_ctrl_fixup_buffer_details(opx_data, terminal_id, resp);
        }
        else
        {
            term_idx = (terminal_id&TERMINAL_NUM_MASK)>>1;
84200bcc:	7f f9 d2 d8 	r0 = r7 LSHIFT -1;
84200bd0:	12 c2       	r0 = r0 AND 0x1f;

            /*input terminal. give the output buffer for the channel */
            resp->b.in_place_buff_params.buffer = opx_data->output_buffer[term_idx] ;
84200bd2:	53 54       	r1 = r0 LSHIFT 2;
84200bd4:	41 08       	rMAC = r6 + Null;
84200bd6:	59 00       	rMAC = r1 + rMAC;
84200bd8:	09 98       	rMAC = M[rMAC + 32];
84200bda:	b1 8f       	M[r4 + 24] = rMAC;

            /* Choose terminal associated with the term_idx. */
            resp->b.in_place_buff_params.in_place_terminal = term_idx;
84200bdc:	32 8f       	M[r4 + 16] = r0;
84200bde:	0d 6e       	jump (m) Lc_vol_ctlr_buffer_details_26;

84200be0 <Lc_vol_ctlr_buffer_details_25>:
        }
    }
    else
    {
        /* The output terminal index is directly mapped to the input_buffer array */
        unsigned buffer_idx = (terminal_id&TERMINAL_NUM_MASK);
84200be0:	92 f0 3f 00 	r0 = r7 AND 0x3f;
        /* The input terminal index is the buffer index multiplied by 2. */
        term_idx = buffer_idx << 1;
84200be4:	13 54       	r1 = r0 LSHIFT 1;

        /*output terminal. give the input buffer for the channel */
        resp->b.in_place_buff_params.buffer = opx_data->input_buffer[buffer_idx];
84200be6:	52 54       	r0 = r0 LSHIFT 2;
84200be8:	81 f0 02 e8 	rMAC = M[r6 + r0];
84200bec:	b1 8f       	M[r4 + 24] = rMAC;

        /* Choose terminal associated with the term_idx. */
        resp->b.in_place_buff_params.in_place_terminal = term_idx | TERMINAL_SINK_MASK;
84200bee:	08 f0 00 f0 	rMAC = r1 OR 0x800000;
84200bf2:	00 f3 51 c8 
84200bf6:	31 8f       	M[r4 + 16] = rMAC;

84200bf8 <Lc_vol_ctlr_buffer_details_26>:
    }

    /* Run in place*/
    resp->runs_in_place = TRUE;
84200bf8:	31 92       	rMAC = MBU[r4 + 8];
84200bfa:	11 ff f7 1f 	rMAC = rMAC AND 0xfffffff7;
84200bfe:	49 c9       	rMAC = rMAC OR 0x8;
84200c00:	31 9a       	MB[r4 + 8] = rMAC;

    /* Configured size overrides. */
    if (opx_data->main_buffer_size_cfg != 0)
84200c02:	81 f0 d3 88 	rMAC = M[r6 + 844];
84200c06:	02 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_28;

84200c08 <Lc_vol_ctlr_buffer_details_27>:
    {
        buffer_size = opx_data->main_buffer_size_cfg;
84200c08:	0f 00       	r5 = rMAC + Null;

84200c0a <Lc_vol_ctlr_buffer_details_28>:
    }
    /* Set the asked buffer size. */
    resp->b.in_place_buff_params.size = buffer_size;
84200c0a:	77 8f       	M[r4 + 20] = r5;

#else  /* !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE) */
    resp->b.buffer_size = buffer_size;
#endif /* !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE) */

    return vol_ctrl_fixup_buffer_details(opx_data, terminal_id, resp);
84200c0c:	34 00       	r2 = r4 + Null;
84200c0e:	4b 08       	r1 = r7 + Null;
84200c10:	42 08       	r0 = r6 + Null;
84200c12:	04 f0 27 e9 	call (m) Lc_vol_ctrl_fixup_buffer_details_1;

84200c16 <Lc_vol_ctlr_buffer_details_29>:
}
84200c16:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200c18:	d8 4c       	rts;

84200c1a <$_vol_ctlr_get_sched_info>:

    return TRUE;
}

bool vol_ctlr_get_sched_info(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200c1a:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200c1c:	17 00       	r5 = r0 + Null;
84200c1e:	2e 00       	r4 = r3 + Null;
    OP_SCHED_INFO_RSP* resp;

    resp = base_op_get_sched_info_ex(op_data, message_data, response_id);
84200c20:	ef fd fb ff 	call (m) 0x41c;
84200c24:	3d ef 
    if (resp == NULL)
84200c26:	10 04       	Null = r0 - Null;
84200c28:	09 62       	if NE jump (m) Lc_vol_ctlr_get_sched_info_3;

84200c2a <Lc_vol_ctlr_get_sched_info_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84200c2a:	03 f0 00 60 	r1 = Null + 4096;
84200c2e:	34 00       	r2 = r4 + Null;
84200c30:	3a 00       	r0 = r5 + Null;
84200c32:	ef fd fc ff 	call (m) 0x4bc;
84200c36:	2b e4 
84200c38:	05 6e       	jump (m) Lc_vol_ctlr_get_sched_info_4;

84200c3a <Lc_vol_ctlr_get_sched_info_3>:
    }
    *response_data = resp;
84200c3a:	32 ee       	M[r4 + Null] = r0;

    resp->block_size = VOL_CTRL_BLOCK_SIZE;
84200c3c:	41 20       	rMAC = Null + 1;
84200c3e:	91 8e       	M[r0 + 8] = rMAC;

    return TRUE;
84200c40:	0a 00       	r0 = rMAC + Null;

84200c42 <Lc_vol_ctlr_get_sched_info_4>:
}
84200c42:	f2 48       	popm <FP, r4, r5, rLink>;
84200c44:	d8 4c       	rts;

84200c46 <$_vol_ctlr_timer_task>:

    return TRUE;
}

void vol_ctlr_timer_task(void *kick_object)
{
84200c46:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200c48:	16 00       	r4 = r0 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200c4a:	ef fd fc ff 	call (m) 0x4e6;
84200c4e:	3d e4 
84200c50:	17 00       	r5 = r0 + Null;
    OPERATOR_DATA *op_data = (OPERATOR_DATA*) kick_object;
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(volume_control_wrapper);

    base_op_profiler_start(op_data);
84200c52:	32 00       	r0 = r4 + Null;
84200c54:	ef fd fc ff 	call (m) 0x51e;
84200c58:	2b e6 

    op_extra_data->pending_timer = TIMER_ID_INVALID;
84200c5a:	70 f0 be 8e 	M[r5 + 760] = Null;

    /* Raise a bg int to process */
    opmgr_kick_operator(op_data);
84200c5e:	32 00       	r0 = r4 + Null;
84200c60:	ff fd 15 f0 	call (m) 0x374a;
84200c64:	2b e7 

    base_op_profiler_stop(op_data);
84200c66:	32 00       	r0 = r4 + Null;
84200c68:	ef fd fc ff 	call (m) 0x52c;
84200c6c:	25 e6 

84200c6e <Lc_vol_ctlr_timer_task_2>:
}
84200c6e:	f2 48       	popm <FP, r4, r5, rLink>;
84200c70:	d8 4c       	rts;

84200c72 <$_vol_ctlr_process_data>:
}
#endif /* VOLUME_CONTROL_AUX_TIMING_TRACE */

RUN_FROM_PM_RAM
void vol_ctlr_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
84200c72:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84200c74:	42 de       	M[FP + 32] = r0;
84200c76:	4b de       	M[FP + 36] = r1;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200c78:	ef fd fc ff 	call (m) 0x4e6;
84200c7c:	2f e3 
84200c7e:	12 09       	r8 = r0 + Null;
    unsigned         i,samples_to_process,num_channels,amount,touched_sink;
    unsigned         block_size = VOL_CTRL_BLOCK_SIZE;

    patch_fn(volume_control_process_data_patch);

    op_extra_data->used_all_input = FALSE;
84200c80:	a0 f0 bd 8e 	M[r8 + 756] = Null;

#ifdef VOLUME_CONTROL_AUX_TIMING_TRACE
    uint32 packed_aux_state = pack_aux_state(op_extra_data);
84200c84:	06 f0 2d e3 	call (m) Lc_pack_aux_state_1;
84200c88:	52 de       	M[FP + 40] = r0;
#endif

#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
    /* update timestamp for using aux TTP */
    vol_ctrl_update_current_timestamp(op_extra_data);
84200c8a:	52 08       	r0 = r8 + Null;
84200c8c:	05 f0 25 e3 	call (m) Lc_vol_ctrl_update_current_timestamp_1;
#endif

    /* Accelerators for data/space */
    samples_to_process = MAXINT;
84200c90:	ff f7 f8 f7 	r6 = Null + 2147483647;
84200c94:	ff 7b 
    if(op_extra_data->stream_based)
84200c96:	a0 f0 c3 88 	Null = M[r8 + 780];
84200c9a:	03 60       	if EQ jump (m) Lc_vol_ctlr_process_data_3;

84200c9c <Lc_vol_ctlr_process_data_2>:
    {
        num_channels = 1;
84200c9c:	0b 71       	r9 = Null + 1;
84200c9e:	25 6e       	jump (m) Lc_vol_ctlr_process_data_12;

84200ca0 <Lc_vol_ctlr_process_data_3>:
    }
    else
    {
        if(op_extra_data->wait_on_space_buffer)
84200ca0:	a2 f0 10 88 	r0 = M[r8 + 64];
84200ca4:	0f 60       	if EQ jump (m) Lc_vol_ctlr_process_data_7;

84200ca6 <Lc_vol_ctlr_process_data_4>:
        {
            samples_to_process = cbuffer_calc_amount_space_in_words(op_extra_data->wait_on_space_buffer);
84200ca6:	ff fd c8 f1 	call (m) 0x39d88;
84200caa:	23 e7 
84200cac:	10 09       	r6 = r0 + Null;
            if(samples_to_process<block_size)
84200cae:	08 62       	if NE jump (m) Lc_vol_ctlr_process_data_6;

84200cb0 <Lc_vol_ctlr_process_data_5>:
            {
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_SPACE_LATE);
84200cb0:	c4 20       	r2 = Null + 3;
84200cb2:	52 08       	r0 = r8 + Null;
84200cb4:	4b d8       	r1 = M[FP + 36];
84200cb6:	04 f0 3d e5 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200cba:	0f f0 8f e7 	jump (m) Lc_vol_ctlr_process_data_79;

84200cbe <Lc_vol_ctlr_process_data_6>:
                return;
            }
            op_extra_data->wait_on_space_buffer=NULL;
84200cbe:	a0 f0 10 8e 	M[r8 + 64] = Null;

84200cc2 <Lc_vol_ctlr_process_data_7>:
        }
        if(op_extra_data->wait_on_data_buffer)
84200cc2:	a2 f0 11 88 	r0 = M[r8 + 68];
84200cc6:	0f 60       	if EQ jump (m) Lc_vol_ctlr_process_data_11;

84200cc8 <Lc_vol_ctlr_process_data_8>:
        {
            amount = cbuffer_calc_amount_data_in_words(op_extra_data->wait_on_data_buffer);
84200cc8:	ff fd c8 f1 	call (m) 0x39dd4;
84200ccc:	2d e8 
            if(amount<block_size)
84200cce:	10 04       	Null = r0 - Null;
84200cd0:	08 62       	if NE jump (m) Lc_vol_ctlr_process_data_10;

84200cd2 <Lc_vol_ctlr_process_data_9>:
            {
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_DATA_LATE);
84200cd2:	84 20       	r2 = Null + 2;
84200cd4:	52 08       	r0 = r8 + Null;
84200cd6:	4b d8       	r1 = M[FP + 36];
84200cd8:	04 f0 3b e4 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200cdc:	0f f0 ed e6 	jump (m) Lc_vol_ctlr_process_data_79;

84200ce0 <Lc_vol_ctlr_process_data_10>:
                return;
            }
            op_extra_data->wait_on_data_buffer=NULL;
84200ce0:	a0 f0 11 8e 	M[r8 + 68] = Null;

84200ce4 <Lc_vol_ctlr_process_data_11>:
        }
        num_channels = op_extra_data->num_channels;
84200ce4:	ab f0 17 88 	r9 = M[r8 + 92];

84200ce8 <Lc_vol_ctlr_process_data_12>:
84200ce8:	41 20       	rMAC = Null + 1;
84200cea:	59 de       	M[FP + 44] = rMAC;
    }

    /* Compute channel transfer amount */
    for(i=0;i<num_channels;i++)
84200cec:	06 00       	r4 = Null + Null;
84200cee:	05 6e       	jump (m) Lc_vol_ctlr_process_data_15;

84200cf0 <Lc_vol_ctlr_process_data_13>:
            {
                op_extra_data->wait_on_space_buffer = buffer;
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_SPACE);
                return;
            }
            samples_to_process=amount;
84200cf0:	10 09       	r6 = r0 + Null;
            op_extra_data->used_all_input = FALSE;
84200cf2:	a0 f0 bd 8e 	M[r8 + 756] = Null;

84200cf6 <Lc_vol_ctlr_process_data_14>:
        }
        num_channels = op_extra_data->num_channels;
    }

    /* Compute channel transfer amount */
    for(i=0;i<num_channels;i++)
84200cf6:	76 20       	r4 = r4 + 1;

84200cf8 <Lc_vol_ctlr_process_data_15>:
84200cf8:	bf f6 00 c2 	Null = r4 - r9;
84200cfc:	02 f0 f1 e0 	if C jump (m) Lc_vol_ctlr_process_data_23;

84200d00 <Lc_vol_ctlr_process_data_16>:
    {
        unsigned term_idx = op_extra_data->channels[i].chan_idx;
84200d00:	a1 f0 1a 88 	rMAC = M[r8 + 104];
84200d04:	12 f6 92 c9 	r0 = r4 * 36 (int);
84200d08:	8a e8       	r0 = M[rMAC + r0];
        tCbuffer *buffer;

      buffer = op_extra_data->input_buffer[term_idx];
84200d0a:	52 54       	r0 = r0 LSHIFT 2;
84200d0c:	51 08       	rMAC = r8 + Null;
84200d0e:	51 00       	rMAC = r0 + rMAC;
84200d10:	0f 00       	r5 = rMAC + Null;
84200d12:	79 f0 00 e8 	r7 = M[r5 + Null];
      amount = cbuffer_calc_amount_data_in_words(buffer);
84200d16:	4a 08       	r0 = r7 + Null;
84200d18:	ff fd c8 f1 	call (m) 0x39dd4;
84200d1c:	3d e5 
      if(amount<=samples_to_process)
84200d1e:	8f f2 00 c2 	Null = r0 - r6;
84200d22:	08 f0 a3 e0 	if HI jump (m) Lc_vol_ctlr_process_data_20;

84200d26 <Lc_vol_ctlr_process_data_17>:
      {
            if(amount < block_size)
84200d26:	10 04       	Null = r0 - Null;
84200d28:	0a 62       	if NE jump (m) Lc_vol_ctlr_process_data_19;

84200d2a <Lc_vol_ctlr_process_data_18>:
            {
                op_extra_data->wait_on_data_buffer = buffer;
84200d2a:	a9 f0 11 8e 	M[r8 + 68] = r7;
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_DATA);
84200d2e:	04 00       	r2 = Null + Null;
84200d30:	52 08       	r0 = r8 + Null;
84200d32:	4b d8       	r1 = M[FP + 36];
84200d34:	04 f0 3f e1 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200d38:	0f f0 91 e6 	jump (m) Lc_vol_ctlr_process_data_79;

84200d3c <Lc_vol_ctlr_process_data_19>:
                return;
            }
            samples_to_process=amount;
84200d3c:	10 09       	r6 = r0 + Null;
            op_extra_data->used_all_input = TRUE;
84200d3e:	59 d8       	rMAC = M[FP + 44];
84200d40:	a1 f0 bd 8e 	M[r8 + 756] = rMAC;

84200d44 <Lc_vol_ctlr_process_data_20>:
        }

        buffer = op_extra_data->output_buffer[term_idx];
84200d44:	3f 98       	r5 = M[r5 + 32];
        amount = cbuffer_calc_amount_space_in_words(buffer);
84200d46:	3a 00       	r0 = r5 + Null;
84200d48:	ff fd c8 f1 	call (m) 0x39d88;
84200d4c:	21 e2 

        /* Relatively likely to need changes below */
        patch_fn(volume_control_adjust_amount);

        if(amount<samples_to_process)
84200d4e:	8f f2 00 c2 	Null = r0 - r6;
84200d52:	f2 ff a5 ef 	if C jump (m) Lc_vol_ctlr_process_data_14;

84200d56 <Lc_vol_ctlr_process_data_21>:
        {
            if(amount<block_size)
84200d56:	10 04       	Null = r0 - Null;
84200d58:	cc 63       	if NE jump (m) Lc_vol_ctlr_process_data_13;

84200d5a <Lc_vol_ctlr_process_data_22>:
            {
                op_extra_data->wait_on_space_buffer = buffer;
84200d5a:	a7 f0 10 8e 	M[r8 + 64] = r5;
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_SPACE);
84200d5e:	44 20       	r2 = Null + 1;
84200d60:	52 08       	r0 = r8 + Null;
84200d62:	4b d8       	r1 = M[FP + 36];
84200d64:	04 f0 2f e0 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200d68:	0f f0 e1 e5 	jump (m) Lc_vol_ctlr_process_data_79;

84200d6c <Lc_vol_ctlr_process_data_23>:
    }

    /* Update AUX state.
       If the aux stream doesn't have enough data it indicates a state change */
    unsigned aux_check = (op_extra_data->aux_active | op_extra_data->aux_connected)
        & VOL_CTRL_CHANNEL_MASK;
84200d6c:	a1 f0 b8 88 	rMAC = M[r8 + 736];
84200d70:	a2 f0 b7 88 	r0 = M[r8 + 732];
84200d74:	89 12       	rMAC = rMAC OR r0;
84200d76:	89 c3       	rMAC = rMAC AND 0xff;
84200d78:	61 de       	M[FP + 48] = rMAC;

    /* Relatively likely to need changes below */
    patch_fn(volume_control_aux_check);

    op_extra_data->tc.num_words = samples_to_process;
84200d7a:	a8 f0 b2 8e 	M[r8 + 712] = r6;
    
    if (aux_check != 0)
84200d7e:	08 04       	Null = rMAC - Null;
84200d80:	ed 60       	if EQ jump (m) Lc_vol_ctlr_process_data_58;

84200d82 <Lc_vol_ctlr_process_data_24>:
    {
        vol_ctrl_aux_channel_t* aux_ch;
        unsigned aux_kick = 0;
84200d82:	03 09       	r9 = Null + Null;
        unsigned aux_limit = MAXINT;
84200d84:	ff f7 f1 f7 	rMAC = Null + 2147483647;
84200d88:	ff 7b 
84200d8a:	69 de       	M[FP + 52] = rMAC;

        for (i = 0, aux_ch = &op_extra_data->aux_channel[0];
84200d8c:	07 00       	r5 = Null + Null;
84200d8e:	a6 f0 6c 20 	r4 = r8 + 108;

84200d92 <Lc_vol_ctlr_process_data_25>:
             i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
             i += 1, aux_ch += 1)
        {
            if (aux_ch->buffer == NULL)
84200d92:	32 e8       	r0 = M[r4 + Null];
84200d94:	03 62       	if NE jump (m) Lc_vol_ctlr_process_data_27;

84200d96 <Lc_vol_ctlr_process_data_26>:
            {
                aux_ch->advance_buffer = 0;
84200d96:	f0 8e       	M[r4 + 12] = Null;
84200d98:	2f 6e       	jump (m) Lc_vol_ctlr_process_data_34;

84200d9a <Lc_vol_ctlr_process_data_27>:
            }
            else
            {
                amount = cbuffer_calc_amount_data_in_words(aux_ch->buffer);
84200d9a:	ff fd c8 f1 	call (m) 0x39dd4;
84200d9e:	3b e1 
84200da0:	11 09       	r7 = r0 + Null;
                if (op_extra_data->metadata_aux_channel == aux_ch)
84200da2:	a1 f0 14 88 	rMAC = M[r8 + 80];
84200da6:	88 05       	Null = rMAC - r4;
84200da8:	0b 62       	if NE jump (m) Lc_vol_ctlr_process_data_29;

84200daa <Lc_vol_ctlr_process_data_28>:
                {
                    amount = pl_min(
                            amount,
                            buff_metadata_available_octets(
                                    aux_ch->buffer)
                                    / OCTETS_PER_SAMPLE);
84200daa:	32 e8       	r0 = M[r4 + Null];
84200dac:	ff fd 9d f0 	call (m) 0x14958;
84200db0:	2d ed 
84200db2:	13 00       	r1 = r0 + Null;
84200db4:	4a 08       	r0 = r7 + Null;
84200db6:	5b 50       	r1 = r1 LSHIFT -2;
84200db8:	5f f3 42 ce 	r0 = MIN r1;
84200dbc:	11 09       	r7 = r0 + Null;

84200dbe <Lc_vol_ctlr_process_data_29>:

                /* Kick back any aux inputs which have no data, regardless
                 * of state. This helps to prime aux sources which have not
                 * started yet, or recover from false stall detections.
                 */
                if (amount == 0)
84200dbe:	69 f0 03 8e 	M[r4 + 12] = r7;
84200dc2:	09 62       	if NE jump (m) Lc_vol_ctlr_process_data_31;

84200dc4 <Lc_vol_ctlr_process_data_30>:
                {
                    touched->sinks |= (2 << (2 * i));
84200dc4:	3a 54       	r0 = r5 LSHIFT 1;
84200dc6:	49 d8       	rMAC = M[FP + 36];
84200dc8:	01 f2 92 ce 	r0 = 0x2 LSHIFT r0;
84200dcc:	49 88       	rMAC = M[rMAC + 4];
84200dce:	89 12       	rMAC = rMAC OR r0;
84200dd0:	4a d8       	r0 = M[FP + 36];
84200dd2:	51 8e       	M[r0 + 4] = rMAC;

84200dd4 <Lc_vol_ctlr_process_data_31>:
                }

                /* Only active aux inputs limit the amount of data to process,
                 * because in other states, aux data is not consumed.
                 */
                if (aux_ch->state == AUX_STATE_IN_AUX)
84200dd4:	31 81       	rMAC = MBS[r4 + 4];
84200dd6:	88 24       	Null = rMAC - 2;
84200dd8:	0f 62       	if NE jump (m) Lc_vol_ctlr_process_data_34;

84200dda <Lc_vol_ctlr_process_data_32>:
                {
                    aux_limit = pl_min(aux_limit, amount);
84200dda:	6b d8       	r1 = M[FP + 52];
84200ddc:	4a 08       	r0 = r7 + Null;
84200dde:	5f f2 43 ce 	r1 = MIN r0;
84200de2:	6b de       	M[FP + 52] = r1;
                    if (amount < samples_to_process)
84200de4:	8f f9 00 c2 	Null = r7 - r6;
84200de8:	02 f0 8f e0 	if C jump (m) Lc_vol_ctlr_process_data_34;

84200dec <Lc_vol_ctlr_process_data_33>:
                    {
                        aux_kick |= (2 << (2 * i));
84200dec:	3a 54       	r0 = r5 LSHIFT 1;
84200dee:	01 f2 92 ce 	r0 = 0x2 LSHIFT r0;
84200df2:	00 f2 7b c8 	r9 = r9 OR r0;

84200df6 <Lc_vol_ctlr_process_data_34>:
        unsigned aux_kick = 0;
        unsigned aux_limit = MAXINT;

        for (i = 0, aux_ch = &op_extra_data->aux_channel[0];
             i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
             i += 1, aux_ch += 1)
84200df6:	7f 20       	r5 = r5 + 1;
84200df8:	36 28       	r4 = r4 + 16;
        vol_ctrl_aux_channel_t* aux_ch;
        unsigned aux_kick = 0;
        unsigned aux_limit = MAXINT;

        for (i = 0, aux_ch = &op_extra_data->aux_channel[0];
             i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
84200dfa:	38 26       	Null = r5 - 8;
84200dfc:	cb 65       	if NC jump (m) Lc_vol_ctlr_process_data_25;

84200dfe <Lc_vol_ctlr_process_data_35>:
         * 1/2 kick period of being kicked backwards (details see B-255916).
         * Currently there is one overall state for aux_pending, which means
         * that the handling of more than one independent aux source is
         * likely to be flawed (B-255917).
         */
        if (aux_limit >= samples_to_process)
84200dfe:	69 d8       	rMAC = M[FP + 52];
84200e00:	8f f1 00 c2 	Null = rMAC - r6;
84200e04:	04 64       	if NC jump (m) Lc_vol_ctlr_process_data_37;

84200e06 <Lc_vol_ctlr_process_data_36>:
        {
            op_extra_data->aux_pending = FALSE;
84200e06:	a0 f0 bc 8e 	M[r8 + 752] = Null;
84200e0a:	45 6e       	jump (m) Lc_vol_ctlr_process_data_45;

84200e0c <Lc_vol_ctlr_process_data_37>:
        }
        else
        {
            if (op_extra_data->aux_pending && (aux_limit == 0))
84200e0c:	a0 f0 bc 88 	Null = M[r8 + 752];
84200e10:	1d 60       	if EQ jump (m) Lc_vol_ctlr_process_data_44;

84200e12 <Lc_vol_ctlr_process_data_38>:
84200e12:	69 d8       	rMAC = M[FP + 52];
84200e14:	0b 62       	if NE jump (m) Lc_vol_ctlr_process_data_41;

84200e16 <Lc_vol_ctlr_process_data_39>:
            {
                /* Since entering aux_pending state, no aux data has arrived */
                if (op_extra_data->pending_timer != TIMER_ID_INVALID)
84200e16:	a0 f0 be 88 	Null = M[r8 + 760];
84200e1a:	f6 61       	if EQ jump (m) Lc_vol_ctlr_process_data_36;

84200e1c <Lc_vol_ctlr_process_data_40>:
                {
                    vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_STILL_AUX_PENDING);
84200e1c:	44 21       	r2 = Null + 5;
84200e1e:	52 08       	r0 = r8 + Null;
84200e20:	4b d8       	r1 = M[FP + 36];
84200e22:	03 f0 31 ea 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200e26:	0f f0 a3 e4 	jump (m) Lc_vol_ctlr_process_data_79;

84200e2a <Lc_vol_ctlr_process_data_41>:
            else
            {
                if (op_extra_data->aux_pending)
                {
                    /* Cleanup the timer before restarting it */
                    timer_cancel_event_atomic(&op_extra_data->pending_timer);
84200e2a:	a6 f0 f8 22 	r4 = r8 + 760;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
84200e2e:	ff fd cf f1 	call (m) 0x3ad3a;
84200e32:	2d e8 
    if (*timer_id != TIMER_ID_INVALID)
84200e34:	32 e8       	r0 = M[r4 + Null];
84200e36:	07 60       	if EQ jump (m) Lc_vol_ctlr_process_data_43;

84200e38 <Lc_vol_ctlr_process_data_42>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
84200e38:	04 00       	r2 = Null + Null;
84200e3a:	03 00       	r1 = Null + Null;
84200e3c:	ff fd 2a f0 	call (m) 0x6292;
84200e40:	37 e2 
        *timer_id = TIMER_ID_INVALID;
84200e42:	30 ee       	M[r4 + Null] = Null;

84200e44 <Lc_vol_ctlr_process_data_43>:
    }
    interrupt_unblock();
84200e44:	ff fd cf f1 	call (m) 0x3ad56;
84200e48:	33 e8 

84200e4a <Lc_vol_ctlr_process_data_44>:
                }

                /* (Re-)Start aux_pending */
                touched->sinks |= aux_kick;
84200e4a:	49 d8       	rMAC = M[FP + 36];
84200e4c:	0a 00       	r0 = rMAC + Null;
84200e4e:	49 88       	rMAC = M[rMAC + 4];
84200e50:	00 fb 71 c8 	rMAC = rMAC OR r9;
84200e54:	51 8e       	M[r0 + 4] = rMAC;
                op_extra_data->pending_timer = timer_schedule_event_in(
                    stream_if_get_system_kick_period() / 2,
                    vol_ctlr_timer_task, (void*)op_data );
84200e56:	ff fd 39 f0 	call (m) 0x8146;
84200e5a:	31 e7 
84200e5c:	42 f0 06 f0 	r4 = Null + 69209159;
84200e60:	47 58 
84200e62:	93 53       	r1 = r0 LSHIFT -31;
84200e64:	9a 00       	r0 = r1 + r0;
84200e66:	17 58       	r5 = r0 ASHIFT -1;
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(time_get_time(), time_in), TimerEventFunction, data_pointer);
84200e68:	ff fd 29 f0 	call (m) 0x6100;
84200e6c:	39 e4 
84200e6e:	ba 00       	r0 = r5 + r0;
84200e70:	33 00       	r1 = r4 + Null;
84200e72:	44 d8       	r2 = M[FP + 32];
84200e74:	ff fd 29 f0 	call (m) 0x610a;
84200e78:	37 e4 
}
84200e7a:	a2 f0 be 8e 	M[r8 + 760] = r0;
                op_extra_data->aux_pending = TRUE;
84200e7e:	41 20       	rMAC = Null + 1;
84200e80:	a1 f0 bc 8e 	M[r8 + 752] = rMAC;
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_AUX_PENDING);
84200e84:	04 21       	r2 = Null + 4;
84200e86:	52 08       	r0 = r8 + Null;
84200e88:	4b d8       	r1 = M[FP + 36];
84200e8a:	03 f0 29 e7 	call (m) Lc_vol_ctrl_kick_waiting_1;

                /* Proceed with processing; consume all data from at least one
                 * of the active aux inputs.
                 */
                op_extra_data->tc.num_words = aux_limit;
84200e8e:	69 d8       	rMAC = M[FP + 52];
84200e90:	a1 f0 b2 8e 	M[r8 + 712] = rMAC;

84200e94 <Lc_vol_ctlr_process_data_45>:
        }

        /* Time constants based on samples to process and sample rate */
        vol_ctrl_compute_time_constants(op_extra_data->sample_rate,
                                        op_extra_data->parameters.OFFSET_VOLUME_TC,
                                        &op_extra_data->tc);
84200e94:	a4 f0 c8 22 	r2 = r8 + 712;
84200e98:	a3 f0 a8 88 	r1 = M[r8 + 672];
84200e9c:	a2 f0 3b 88 	r0 = M[r8 + 236];
84200ea0:	06 f0 3b e2 	call (m) $_vol_ctrl_compute_time_constants;
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
        /* There is a possibility that vol_ctrl_update_aux_state
         * limits the number of samples to process, so keep a copy
         * of that now.
         */
        samples_to_process = op_extra_data->tc.num_words;
84200ea4:	a6 f0 b2 88 	r4 = M[r8 + 712];
#endif

        vol_ctrl_update_aux_state(op_extra_data, aux_check, &op_extra_data->tc);
84200ea8:	a4 f0 c8 22 	r2 = r8 + 712;
84200eac:	52 08       	r0 = r8 + Null;
84200eae:	63 d8       	r1 = M[FP + 48];
84200eb0:	05 f0 31 e6 	call (m) $_vol_ctrl_update_aux_state;
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
        /* whole of this block is for debugging purpose only,
         * showing to user whether aux is being mixed in timed mode
         * or normal mode.
         */
        if(op_extra_data->dbg_aux_mixing_started)
84200eb4:	a0 f0 d1 88 	Null = M[r8 + 836];
84200eb8:	33 60       	if EQ jump (m) Lc_vol_ctlr_process_data_55;

84200eba <Lc_vol_ctlr_process_data_46>:
        {
            if(op_extra_data->current_timestamp_valid && op_extra_data->aux0_ttp.enabled)
84200eba:	a0 f0 cd 88 	Null = M[r8 + 820];
84200ebe:	1d 60       	if EQ jump (m) Lc_vol_ctlr_process_data_51;

84200ec0 <Lc_vol_ctlr_process_data_47>:
84200ec0:	a0 f0 c4 88 	Null = M[r8 + 784];
84200ec4:	1a 60       	if EQ jump (m) Lc_vol_ctlr_process_data_51;

84200ec6 <Lc_vol_ctlr_process_data_48>:
                L2_DBG_MSG3("Volume Control: Started mixing auxiliary input in playback mode, "
                            "requested ttp: %d, mixed at=%d, diff=%d",
                            op_extra_data->aux0_ttp.time_to_play,
                            op_extra_data->current_timestamp,
                            time_sub(op_extra_data->current_timestamp,
                                     op_extra_data->aux0_ttp.time_to_play));
84200ec6:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200eca:	88 24       	Null = rMAC - 2;
84200ecc:	0c 68       	if LT jump (m) Lc_vol_ctlr_process_data_50;

84200ece <Lc_vol_ctlr_process_data_49>:
84200ece:	a3 f0 c5 88 	r1 = M[r8 + 788];
84200ed2:	a4 f0 cc 88 	r2 = M[r8 + 816];
84200ed6:	e5 04       	r3 = r2 - r1;
84200ed8:	55 f1 02 f0 	r0 = Null + 357564595;
84200edc:	b3 40 
84200ede:	ef fd ff ff 	call (m) 0xd08;
84200ee2:	2b e1 

84200ee4 <Lc_vol_ctlr_process_data_50>:

                record_aux_ttr_event(op_data,
                                     VOL_CTRL_TTR_EVENT_AUX_STARTED_MIXING,
                                     op_extra_data->aux0_ttp.time_to_play,
                                     op_extra_data->current_timestamp);
84200ee4:	a5 f0 cc 88 	r3 = M[r8 + 816];
84200ee8:	a4 f0 c5 88 	r2 = M[r8 + 788];
84200eec:	03 f0 45 40 	r1 = Null + 69;
84200ef0:	42 d8       	r0 = M[FP + 32];
84200ef2:	05 f0 21 e1 	call (m) Lc_record_aux_ttr_event_1;
84200ef6:	12 6e       	jump (m) Lc_vol_ctlr_process_data_54;

84200ef8 <Lc_vol_ctlr_process_data_51>:
            }
            else
            {
                L2_DBG_MSG("Volume Control: Started mixing auxiliary input in non-timed playback mode");
84200ef8:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200efc:	88 24       	Null = rMAC - 2;
84200efe:	07 68       	if LT jump (m) Lc_vol_ctlr_process_data_53;

84200f00 <Lc_vol_ctlr_process_data_52>:
84200f00:	55 f1 02 f0 	r0 = Null + 357564700;
84200f04:	1c 41 
84200f06:	ef fd fe ff 	call (m) 0xccc;
84200f0a:	27 ee 

84200f0c <Lc_vol_ctlr_process_data_53>:

                record_aux_ttr_event(op_data,
                                     VOL_CTRL_TTR_EVENT_AUX_STARTED_MIXING,
                                     0,
                                     0);
84200f0c:	03 f0 45 40 	r1 = Null + 69;
84200f10:	05 00       	r3 = Null + Null;
84200f12:	04 00       	r2 = Null + Null;
84200f14:	42 d8       	r0 = M[FP + 32];
84200f16:	04 f0 3d ef 	call (m) Lc_record_aux_ttr_event_1;

84200f1a <Lc_vol_ctlr_process_data_54>:
            }
            op_extra_data->dbg_aux_mixing_started = FALSE;
84200f1a:	a0 f0 d1 8e 	M[r8 + 836] = Null;

84200f1e <Lc_vol_ctlr_process_data_55>:
        }

        if(samples_to_process > op_extra_data->tc.num_words)
84200f1e:	a1 f0 b2 88 	rMAC = M[r8 + 712];
84200f22:	70 04       	Null = r4 - rMAC;
84200f24:	09 f0 cb e0 	if LS jump (m) Lc_vol_ctlr_process_data_59;

84200f28 <Lc_vol_ctlr_process_data_56>:
             */

            /* recalculate time constants based on limited amount */
            vol_ctrl_compute_time_constants(op_extra_data->sample_rate,
                                            op_extra_data->parameters.OFFSET_VOLUME_TC,
                                            &op_extra_data->tc);
84200f28:	a4 f0 c8 22 	r2 = r8 + 712;
84200f2c:	a3 f0 a8 88 	r1 = M[r8 + 672];
84200f30:	a2 f0 3b 88 	r0 = M[r8 + 236];
84200f34:	05 f0 27 ee 	call (m) $_vol_ctrl_compute_time_constants;

            /* Also do a self kick to process the rest of chunk immediately.*/
            if (op_extra_data->pending_timer == TIMER_ID_INVALID)
84200f38:	a0 f0 be 88 	Null = M[r8 + 760];
84200f3c:	19 62       	if NE jump (m) Lc_vol_ctlr_process_data_59;

84200f3e <Lc_vol_ctlr_process_data_57>:
            {
                op_extra_data->pending_timer =
                    timer_schedule_event_in(0, vol_ctlr_timer_task, (void*)op_data );
84200f3e:	42 f0 06 f0 	r4 = Null + 69209159;
84200f42:	47 58 
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(time_get_time(), time_in), TimerEventFunction, data_pointer);
84200f44:	ff fd 28 f0 	call (m) 0x6100;
84200f48:	3d ed 
84200f4a:	33 00       	r1 = r4 + Null;
84200f4c:	44 d8       	r2 = M[FP + 32];
84200f4e:	ff fd 28 f0 	call (m) 0x610a;
84200f52:	3d ed 
}
84200f54:	a2 f0 be 8e 	M[r8 + 760] = r0;
84200f58:	0b 6e       	jump (m) Lc_vol_ctlr_process_data_59;

84200f5a <Lc_vol_ctlr_process_data_58>:
#endif  /* VOLUME_CONTROL_AUX_TTP_SUPPORT  */

    }
    else
    {
        op_extra_data->aux_pending = FALSE;
84200f5a:	a0 f0 bc 8e 	M[r8 + 752] = Null;

        /* Time constants based on samples to process and sample rate */
        vol_ctrl_compute_time_constants(op_extra_data->sample_rate,
                                        op_extra_data->parameters.OFFSET_VOLUME_TC,
                                        &op_extra_data->tc);
84200f5e:	a4 f0 c8 22 	r2 = r8 + 712;
84200f62:	a3 f0 a8 88 	r1 = M[r8 + 672];
84200f66:	a2 f0 3b 88 	r0 = M[r8 + 236];
84200f6a:	05 f0 31 ec 	call (m) $_vol_ctrl_compute_time_constants;

84200f6e <Lc_vol_ctlr_process_data_59>:
    }

    if (! op_extra_data->aux_pending)
84200f6e:	a0 f0 bc 88 	Null = M[r8 + 752];
84200f72:	11 62       	if NE jump (m) Lc_vol_ctlr_process_data_63;

84200f74 <Lc_vol_ctlr_process_data_60>:
    {
        timer_cancel_event_atomic(&op_extra_data->pending_timer);
84200f74:	a6 f0 f8 22 	r4 = r8 + 760;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
84200f78:	ff fd ce f1 	call (m) 0x3ad3a;
84200f7c:	23 ee 
    if (*timer_id != TIMER_ID_INVALID)
84200f7e:	32 e8       	r0 = M[r4 + Null];
84200f80:	07 60       	if EQ jump (m) Lc_vol_ctlr_process_data_62;

84200f82 <Lc_vol_ctlr_process_data_61>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
84200f82:	04 00       	r2 = Null + Null;
84200f84:	03 00       	r1 = Null + Null;
84200f86:	ff fd 29 f0 	call (m) 0x6292;
84200f8a:	2d e8 
        *timer_id = TIMER_ID_INVALID;
84200f8c:	30 ee       	M[r4 + Null] = Null;

84200f8e <Lc_vol_ctlr_process_data_62>:
    }
    interrupt_unblock();
84200f8e:	ff fd ce f1 	call (m) 0x3ad56;
84200f92:	29 ee 

84200f94 <Lc_vol_ctlr_process_data_63>:
    }

#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
    /* update amount that is consumed this run */
    op_extra_data->prev_consumed_samples = op_extra_data->tc.num_words;
84200f94:	a1 f0 b2 88 	rMAC = M[r8 + 712];
#endif
    if (op_extra_data->tc.num_words > 0)
84200f98:	a1 f0 cf 8e 	M[r8 + 828] = rMAC;
84200f9c:	11 60       	if EQ jump (m) Lc_vol_ctlr_process_data_65;

84200f9e <Lc_vol_ctlr_process_data_64>:
    {
#ifdef INSTALL_METADATA
        metadata_tag* eoftag = vol_ctrl_handle_aux_metadata(op_extra_data);
84200f9e:	52 08       	r0 = r8 + Null;
84200fa0:	02 f0 35 ee 	call (m) Lc_vol_ctrl_handle_aux_metadata_1;
        vol_ctrl_handle_input_metadata(op_extra_data, eoftag);
84200fa4:	13 00       	r1 = r0 + Null;
84200fa6:	52 08       	r0 = r8 + Null;
84200fa8:	03 f0 21 e1 	call (m) Lc_vol_ctrl_handle_input_metadata_1;
#endif  /* INSTALL_METADATA */

        /* Update Main Channels */
        vol_ctrl_update_channel(op_extra_data,op_extra_data->channels,op_extra_data->lpvols,&op_extra_data->tc);
84200fac:	a5 f0 c8 22 	r3 = r8 + 712;
84200fb0:	a4 f0 62 88 	r2 = M[r8 + 392];
84200fb4:	a3 f0 1a 88 	r1 = M[r8 + 104];
84200fb8:	52 08       	r0 = r8 + Null;
84200fba:	f8 ff 26 e2 	call $_vol_ctrl_update_channel;

84200fbe <Lc_vol_ctlr_process_data_65>:
    }

#ifdef VOLUME_CONTROL_AUX_TIMING_TRACE
    uint32 updated_aux_state = pack_aux_state(op_extra_data);
84200fbe:	52 08       	r0 = r8 + Null;
84200fc0:	04 f0 31 e9 	call (m) Lc_pack_aux_state_1;
    if (updated_aux_state != packed_aux_state)
84200fc4:	51 d8       	rMAC = M[FP + 40];
84200fc6:	50 04       	Null = r0 - rMAC;
84200fc8:	08 60       	if EQ jump (m) Lc_vol_ctlr_process_data_67;

84200fca <Lc_vol_ctlr_process_data_66>:
    {
        record_aux_ttr_event(op_data, VOL_CTRL_TTR_EVENT_AUX_STATE,
                             updated_aux_state, 0);
84200fca:	03 f0 44 40 	r1 = Null + 68;
84200fce:	05 00       	r3 = Null + Null;
84200fd0:	14 00       	r2 = r0 + Null;
84200fd2:	42 d8       	r0 = M[FP + 32];
84200fd4:	04 f0 3f e9 	call (m) Lc_record_aux_ttr_event_1;

84200fd8 <Lc_vol_ctlr_process_data_67>:
    }
#endif /* VOLUME_CONTROL_AUX_TIMING_TRACE */

    /* Handle backwards kicks for main channels */
    touched_sink = (op_extra_data->used_all_input) ? op_extra_data->touched_sink : 0;
84200fd8:	a0 f0 bd 88 	Null = M[r8 + 756];
84200fdc:	04 60       	if EQ jump (m) Lc_vol_ctlr_process_data_69;

84200fde <Lc_vol_ctlr_process_data_68>:
84200fde:	a6 f0 18 88 	r4 = M[r8 + 96];
84200fe2:	02 6e       	jump (m) Lc_vol_ctlr_process_data_70;

84200fe4 <Lc_vol_ctlr_process_data_69>:
84200fe4:	06 00       	r4 = Null + Null;

84200fe6 <Lc_vol_ctlr_process_data_70>:

    /* Update Aux Buffers */
    op_extra_data->aux_state   = 0;
84200fe6:	a0 f0 b9 8e 	M[r8 + 740] = Null;
    amount    = op_extra_data->aux_connected;
    if(amount)
84200fea:	a8 f0 b7 88 	r6 = M[r8 + 732];
84200fee:	25 60       	if EQ jump (m) Lc_vol_ctlr_process_data_78;

84200ff0 <Lc_vol_ctlr_process_data_71>:
    {
        vol_ctrl_aux_channel_t *aux_ptr=op_extra_data->aux_channel;
84200ff0:	a7 f0 6c 20 	r5 = r8 + 108;
        i = 0;
84200ff4:	01 09       	r7 = Null + Null;

84200ff6 <Lc_vol_ctlr_process_data_72>:
        do
        {
            if(aux_ptr->state==AUX_STATE_IN_AUX)
84200ff6:	39 81       	rMAC = MBS[r5 + 4];
84200ff8:	88 24       	Null = rMAC - 2;
84200ffa:	0e 62       	if NE jump (m) Lc_vol_ctlr_process_data_75;

84200ffc <Lc_vol_ctlr_process_data_73>:
            {
                unsigned index_mask = (1<<i);
84200ffc:	49 08       	rMAC = r7 + Null;
84200ffe:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
                op_extra_data->aux_state |= index_mask;
84201002:	a1 f0 b9 88 	rMAC = M[r8 + 740];
84201006:	89 12       	rMAC = rMAC OR r0;
84201008:	a1 f0 b9 8e 	M[r8 + 740] = rMAC;
                // only advance if used by a channel?
                if(!(op_extra_data->aux_in_use&index_mask))
8420100c:	a1 f0 ba 88 	rMAC = M[r8 + 744];
84201010:	89 10       	rMAC = rMAC AND r0;
84201012:	02 62       	if NE jump (m) Lc_vol_ctlr_process_data_75;

84201014 <Lc_vol_ctlr_process_data_74>:
                {
                    aux_ptr->advance_buffer=0;
84201014:	f8 8e       	M[r5 + 12] = Null;

84201016 <Lc_vol_ctlr_process_data_75>:
                }
            }
            if(aux_ptr->advance_buffer)
84201016:	fb 88       	r1 = M[r5 + 12];
84201018:	0b 60       	if EQ jump (m) Lc_vol_ctlr_process_data_77;

8420101a <Lc_vol_ctlr_process_data_76>:
            {
                touched_sink |= ( TOUCHED_SINK_0 << ((i<<1)+1) );
8420101a:	00 f9 d2 d8 	r0 = r7 LSHIFT 1;
8420101e:	51 20       	rMAC = r0 + 1;
84201020:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84201024:	b6 12       	r4 = r4 OR r0;
                cbuffer_advance_read_ptr(aux_ptr->buffer,aux_ptr->advance_buffer);
84201026:	3a e8       	r0 = M[r5 + Null];
84201028:	ff fd c6 f1 	call (m) 0x39de2;
8420102c:	3b ed 

8420102e <Lc_vol_ctlr_process_data_77>:
            }
            i++;
8420102e:	09 75       	r7 = r7 + 1;
            aux_ptr++;
84201030:	3f 28       	r5 = r5 + 16;
            amount>>=1;
        }while(amount);
84201032:	7f f8 d8 d8 	r6 = r6 LSHIFT -1;
84201036:	e0 63       	if NE jump (m) Lc_vol_ctlr_process_data_72;

84201038 <Lc_vol_ctlr_process_data_78>:
    }

   touched->sinks |= touched_sink;
84201038:	49 d8       	rMAC = M[FP + 36];
8420103a:	0a 00       	r0 = rMAC + Null;
8420103c:	49 88       	rMAC = M[rMAC + 4];
8420103e:	89 13       	rMAC = rMAC OR r4;
84201040:	51 8e       	M[r0 + 4] = rMAC;
   touched->sources = op_extra_data->touched_src;
84201042:	a1 f0 19 88 	rMAC = M[r8 + 100];
84201046:	11 ee       	M[r0 + Null] = rMAC;

84201048 <Lc_vol_ctlr_process_data_79>:

}
84201048:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420104a:	d8 4c       	rts;

8420104c <$_vol_ctlr_opmsg_obpm_set_control>:


/* **************************** Operator message handlers ******************************** */

bool vol_ctlr_opmsg_obpm_set_control(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420104c:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
8420104e:	11 09       	r7 = r0 + Null;
84201050:	43 de       	M[FP + 32] = r1;
84201052:	27 00       	r5 = r2 + Null;
84201054:	4d de       	M[FP + 36] = r3;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201056:	ef fd fa ff 	call (m) 0x4e6;
8420105a:	31 e4 
8420105c:	16 00       	r4 = r0 + Null;
bool vol_ctlr_opmsg_obpm_set_control(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T    *op_extra_data = get_instance_data(op_data);
    unsigned            i,num_controls,cntrl_value;
    CPS_CONTROL_SOURCE  cntrl_src;
    OPMSG_RESULT_STATES result = OPMSG_RESULT_STATES_NORMAL_STATE;
8420105e:	50 de       	M[FP + 40] = Null;
    vol_ctrl_gains_t *lpvols =&op_extra_data->host_vol;
84201060:	68 f0 f8 20 	r6 = r4 + 248;
    bool              bIsOBPM=FALSE;
84201064:	02 09       	r8 = Null + Null;

    patch_fn(volume_control_opmsg_obpm_set_control_patch);

    if(!cps_control_setup(message_data, resp_length, resp_data,&num_controls))
84201066:	c5 12       	r3 = FP + 44;
84201068:	3b 00       	r1 = r5 + Null;
8420106a:	4c d8       	r2 = M[FP + 36];
8420106c:	42 d8       	r0 = M[FP + 32];
8420106e:	ef fd fd ff 	call (m) 0xab2;
84201072:	25 e2 
84201074:	10 04       	Null = r0 - Null;
84201076:	03 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_3;

84201078 <Lc_vol_ctlr_opmsg_obpm_set_control_2>:
84201078:	02 00       	r0 = Null + Null;
8420107a:	8b 6e       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_31;

8420107c <Lc_vol_ctlr_opmsg_obpm_set_control_3>:
8420107c:	0b 71       	r9 = Null + 1;
    {
        return FALSE;
    }

    for(i=0;i<num_controls;i++)
8420107e:	07 00       	r5 = Null + Null;
84201080:	0e 6e       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_8;

84201082 <Lc_vol_ctlr_opmsg_obpm_set_control_4>:
                 (cntrl_id<=VOL_CTRL_CONSTANT_TRIM8_GAIN_CTRL) )
        {
            lpvols->channel_trims[cntrl_id-VOL_CTRL_CONSTANT_TRIM1_GAIN_CTRL] = cntrl_value;
        }
        else if( (cntrl_id>=VOL_CTRL_CONSTANT_AUX_GAIN_CTRL1) &&
                 (cntrl_id<=VOL_CTRL_CONSTANT_AUX_GAIN_CTRL8) )
84201082:	10 3c       	Null = r0 - 48;
84201084:	29 64       	if NC jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_14;

84201086 <Lc_vol_ctlr_opmsg_obpm_set_control_5>:
84201086:	d0 3d       	Null = r0 - 55;
84201088:	08 f0 cf e0 	if HI jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_14;

8420108c <Lc_vol_ctlr_opmsg_obpm_set_control_6>:
        {
            lpvols->auxiliary_gain[cntrl_id-VOL_CTRL_CONSTANT_AUX_GAIN_CTRL1] = cntrl_value;
8420108c:	63 d8       	r1 = M[FP + 48];
8420108e:	f2 f7 d0 7f 	r0 = r0 + -48;
84201092:	41 08       	rMAC = r6 + Null;
84201094:	52 54       	r0 = r0 LSHIFT 2;
84201096:	51 00       	rMAC = r0 + rMAC;
84201098:	8b 8e       	M[rMAC + 8] = r1;

8420109a <Lc_vol_ctlr_opmsg_obpm_set_control_7>:
    if(!cps_control_setup(message_data, resp_length, resp_data,&num_controls))
    {
        return FALSE;
    }

    for(i=0;i<num_controls;i++)
8420109a:	7f 20       	r5 = r5 + 1;

8420109c <Lc_vol_ctlr_opmsg_obpm_set_control_8>:
8420109c:	59 d8       	rMAC = M[FP + 44];
8420109e:	78 04       	Null = r5 - rMAC;
842010a0:	02 f0 bb e0 	if C jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_15;

842010a4 <Lc_vol_ctlr_opmsg_obpm_set_control_9>:
    {
        unsigned  cntrl_id=cps_control_get(message_data,i,&cntrl_value,&cntrl_src);
842010a4:	45 13       	r3 = FP + 52;
842010a6:	04 13       	r2 = FP + 48;
842010a8:	3b 00       	r1 = r5 + Null;
842010aa:	42 d8       	r0 = M[FP + 32];
842010ac:	ef fd fd ff 	call (m) 0xb00;
842010b0:	35 e2 

        /* Check for OBPM and Override.   Override is all or none, not per control */
        if((i==0)&&(cntrl_src != CPS_SOURCE_HOST))
842010b2:	38 04       	Null = r5 - Null;
842010b4:	0c 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_12;

842010b6 <Lc_vol_ctlr_opmsg_obpm_set_control_10>:
842010b6:	a1 d1       	rMAC = MBS[FP + 52];
842010b8:	0a 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_12;

842010ba <Lc_vol_ctlr_opmsg_obpm_set_control_11>:
        {
            bIsOBPM = TRUE;
842010ba:	5a 09       	r8 = r9 + Null;
            lpvols  = &op_extra_data->obpm_vol;
842010bc:	68 f0 40 21 	r6 = r4 + 320;
            /* Polarity of override enable/disable is inverted */
            op_extra_data->Ovr_Control = (cntrl_src == CPS_SOURCE_OBPM_DISABLE) ?  VOL_CTRL_CONTROL_VOL_OVERRIDE : 0;
842010c0:	03 00       	r1 = Null + Null;
842010c2:	c8 24       	Null = rMAC - 3;
842010c4:	20 f0 43 ce 	if EQ r1 = Null + 1;
842010c8:	63 f0 3c 8e 	M[r4 + 240] = r1;

842010cc <Lc_vol_ctlr_opmsg_obpm_set_control_12>:
        }

        if(cntrl_id==VOL_CTRL_CONSTANT_POST_GAIN_CTRL)
842010cc:	10 34       	Null = r0 - 32;
842010ce:	1a 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_18;

842010d0 <Lc_vol_ctlr_opmsg_obpm_set_control_13>:
        {
            if(bIsOBPM)
842010d0:	0f fa 00 c2 	Null = r8 - Null;
842010d4:	0c 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_17;

842010d6 <Lc_vol_ctlr_opmsg_obpm_set_control_14>:
            {
                /* OBPM can not set post gain */
                result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
842010d6:	01 21       	rMAC = Null + 4;
842010d8:	51 de       	M[FP + 40] = rMAC;

842010da <Lc_vol_ctlr_opmsg_obpm_set_control_15>:
            result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
            break;
        }
    }

    if(op_extra_data->Ovr_Control&VOL_CTRL_CONTROL_VOL_OVERRIDE)
842010da:	61 f0 3c 88 	rMAC = M[r4 + 240];
842010de:	09 c0       	rMAC = rMAC AND 0x1;
842010e0:	48 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_29;

842010e2 <Lc_vol_ctlr_opmsg_obpm_set_control_16>:
    {
        op_extra_data->lpvols = &op_extra_data->obpm_vol;
842010e2:	61 f0 40 21 	rMAC = r4 + 320;
842010e6:	61 f0 62 8e 	M[r4 + 392] = rMAC;
842010ea:	47 6e       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_30;

842010ec <Lc_vol_ctlr_opmsg_obpm_set_control_17>:
                /* OBPM can not set post gain */
                result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
                break;
            }

            op_extra_data->post_gain = cntrl_value;
842010ec:	61 d8       	rMAC = M[FP + 48];
842010ee:	61 f0 3d 8e 	M[r4 + 244] = rMAC;

            op_extra_data->shared_volume_ptr->inv_post_gain = dB60toLinearQ5(-op_extra_data->post_gain);
842010f2:	42 04       	r0 = Null - rMAC;
842010f4:	ff fd b7 f1 	call (m) 0x37fbe;
842010f8:	2b e6 
842010fa:	61 f0 63 88 	rMAC = M[r4 + 396];
842010fe:	ca 8e       	M[rMAC + 12] = r0;
84201100:	cd 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

84201102 <Lc_vol_ctlr_opmsg_obpm_set_control_18>:
        }
        else if(cntrl_id==VOL_CTRL_CONSTANT_MASTER_GAIN_CTRL)
84201102:	50 34       	Null = r0 - 33;
84201104:	0d 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_21;

84201106 <Lc_vol_ctlr_opmsg_obpm_set_control_19>:
        {
            lpvols->master_gain = cntrl_value;
84201106:	61 d8       	rMAC = M[FP + 48];
84201108:	81 f0 00 ee 	M[r6 + Null] = rMAC;
            if (!opmgr_op_is_running(op_data))
8420110c:	4a 08       	r0 = r7 + Null;
8420110e:	ff fd 22 f0 	call (m) 0x5700;
84201112:	33 ef 
84201114:	10 04       	Null = r0 - Null;
84201116:	c2 63       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

84201118 <Lc_vol_ctlr_opmsg_obpm_set_control_20>:
            {
                op_extra_data->vol_initialised = 1;
84201118:	6b f0 bf 8e 	M[r4 + 764] = r9;
8420111c:	bf 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

8420111e <Lc_vol_ctlr_opmsg_obpm_set_control_21>:
            }
        }
        else if(cntrl_id==OPMSG_CONTROL_MUTE_ID)
8420111e:	90 24       	Null = r0 - 2;
84201120:	10 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_24;

84201122 <Lc_vol_ctlr_opmsg_obpm_set_control_22>:
        {
            lpvols->mute = cntrl_value;
84201122:	61 d8       	rMAC = M[FP + 48];
84201124:	81 f0 01 8e 	M[r6 + 4] = rMAC;
            if (opmgr_op_is_running(op_data))
84201128:	4a 08       	r0 = r7 + Null;
8420112a:	ff fd 22 f0 	call (m) 0x5700;
8420112e:	37 ee 
84201130:	10 04       	Null = r0 - Null;
84201132:	b4 61       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

84201134 <Lc_vol_ctlr_opmsg_obpm_set_control_23>:
            {
                vol_ctrl_setup_mute(op_extra_data,lpvols->mute);
84201134:	83 f0 01 88 	r1 = M[r6 + 4];
84201138:	32 00       	r0 = r4 + Null;
8420113a:	03 f0 31 ea 	call (m) Lc_vol_ctrl_setup_mute_1;
8420113e:	ae 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

84201140 <Lc_vol_ctlr_opmsg_obpm_set_control_24>:
            }
        }
        else if(cntrl_id==VOL_CTRL_CONSTANT_MUTE_PERIOD_CTRL)
84201140:	90 34       	Null = r0 - 34;
84201142:	0b 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_26;

84201144 <Lc_vol_ctlr_opmsg_obpm_set_control_25>:
        {
            op_extra_data->mute_period = cntrl_value;
84201144:	61 d8       	rMAC = M[FP + 48];
84201146:	61 f0 c0 8e 	M[r4 + 768] = rMAC;
            if (opmgr_op_is_running(op_data))
8420114a:	4a 08       	r0 = r7 + Null;
8420114c:	ff fd 22 f0 	call (m) 0x5700;
84201150:	35 ed 
84201152:	10 04       	Null = r0 - Null;
84201154:	f0 63       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_23;

84201156 <Lc__ite_12>:
84201156:	a2 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

84201158 <Lc_vol_ctlr_opmsg_obpm_set_control_26>:
            {
                vol_ctrl_setup_mute(op_extra_data,lpvols->mute);
            }
        }
        else if( (cntrl_id>=VOL_CTRL_CONSTANT_TRIM1_GAIN_CTRL) &&
                 (cntrl_id<=VOL_CTRL_CONSTANT_TRIM8_GAIN_CTRL) )
84201158:	10 2c       	Null = r0 - 16;
8420115a:	be 65       	if NC jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_14;

8420115c <Lc_vol_ctlr_opmsg_obpm_set_control_27>:
8420115c:	d0 2d       	Null = r0 - 23;
8420115e:	f8 ff a5 ee 	if HI jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_4;

84201162 <Lc_vol_ctlr_opmsg_obpm_set_control_28>:
        {
            lpvols->channel_trims[cntrl_id-VOL_CTRL_CONSTANT_TRIM1_GAIN_CTRL] = cntrl_value;
84201162:	63 d8       	r1 = M[FP + 48];
84201164:	82 7c       	r0 = r0 + -16;
84201166:	41 08       	rMAC = r6 + Null;
84201168:	52 54       	r0 = r0 LSHIFT 2;
8420116a:	51 00       	rMAC = r0 + rMAC;
8420116c:	8b 9e       	M[rMAC + 40] = r1;
8420116e:	96 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

84201170 <Lc_vol_ctlr_opmsg_obpm_set_control_29>:
    {
        op_extra_data->lpvols = &op_extra_data->obpm_vol;
    }
    else
    {
        op_extra_data->lpvols = &op_extra_data->host_vol;
84201170:	61 f0 f8 20 	rMAC = r4 + 248;
84201174:	61 f0 62 8e 	M[r4 + 392] = rMAC;

84201178 <Lc_vol_ctlr_opmsg_obpm_set_control_30>:
    }
    op_extra_data->shared_volume_ptr->current_volume_level = op_extra_data->lpvols->master_gain;
84201178:	61 f0 62 88 	rMAC = M[r4 + 392];
8420117c:	62 f0 63 88 	r0 = M[r4 + 396];
84201180:	09 e8       	rMAC = M[rMAC + Null];
84201182:	91 8e       	M[r0 + 8] = rMAC;


    cps_response_set_result(resp_data,result);
84201184:	53 d8       	r1 = M[FP + 40];
84201186:	4a d8       	r0 = M[FP + 36];
84201188:	ef fd fc ff 	call (m) 0xb4e;
8420118c:	27 ee 

    return TRUE;
8420118e:	5a 08       	r0 = r9 + Null;

84201190 <Lc_vol_ctlr_opmsg_obpm_set_control_31>:
}
84201190:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201192:	d8 4c       	rts;

84201194 <$_vol_ctlr_opmsg_obpm_get_params>:

bool vol_ctlr_opmsg_obpm_get_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201194:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201196:	1f 00       	r5 = r1 + Null;
84201198:	26 00       	r4 = r2 + Null;
8420119a:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
8420119c:	ef fd f9 ff 	call (m) 0x4e6;
842011a0:	2b ea 

bool vol_ctlr_opmsg_obpm_get_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    return cpsGetParameterMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
842011a2:	02 f0 b4 46 	r0 = r0 + 692;
842011a6:	45 08       	r3 = r6 + Null;
842011a8:	34 00       	r2 = r4 + Null;
842011aa:	3b 00       	r1 = r5 + Null;
842011ac:	ef fd fa ff 	call (m) 0x792;
842011b0:	27 ef 

842011b2 <Lc_vol_ctlr_opmsg_obpm_get_params_2>:
}
842011b2:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842011b4:	d8 4c       	rts;

842011b6 <$_vol_ctlr_opmsg_obpm_get_defaults>:

bool vol_ctlr_opmsg_obpm_get_defaults(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842011b6:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842011b8:	1f 00       	r5 = r1 + Null;
842011ba:	26 00       	r4 = r2 + Null;
842011bc:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842011be:	ef fd f9 ff 	call (m) 0x4e6;
842011c2:	29 e9 

bool vol_ctlr_opmsg_obpm_get_defaults(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    return cpsGetDefaultsMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
842011c4:	02 f0 b4 46 	r0 = r0 + 692;
842011c8:	45 08       	r3 = r6 + Null;
842011ca:	34 00       	r2 = r4 + Null;
842011cc:	3b 00       	r1 = r5 + Null;
842011ce:	ef fd fb ff 	call (m) 0x840;
842011d2:	33 e3 

842011d4 <Lc_vol_ctlr_opmsg_obpm_get_defaults_2>:
}
842011d4:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842011d6:	d8 4c       	rts;

842011d8 <$_vol_ctlr_opmsg_obpm_set_params>:

bool vol_ctlr_opmsg_obpm_set_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842011d8:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842011da:	19 09       	r7 = r1 + Null;
842011dc:	27 00       	r5 = r2 + Null;
842011de:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842011e0:	ef fd f9 ff 	call (m) 0x4e6;
842011e4:	27 e8 
842011e6:	16 00       	r4 = r0 + Null;
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    bool retval;

    patch_fn(volume_control_opmsg_obpm_set_params_patch);

    retval = cpsSetParameterMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
842011e8:	62 f0 b4 22 	r0 = r4 + 692;
842011ec:	45 08       	r3 = r6 + Null;
842011ee:	3c 00       	r2 = r5 + Null;
842011f0:	4b 08       	r1 = r7 + Null;
842011f2:	ef fd fb ff 	call (m) 0x914;
842011f6:	23 e9 

    /* Set the Reinit flag after setting the parameters */
    op_extra_data->ReInitFlag = 1;
842011f8:	41 20       	rMAC = Null + 1;
842011fa:	61 f0 ac 8e 	M[r4 + 688] = rMAC;

842011fe <Lc_vol_ctlr_opmsg_obpm_set_params_2>:

    return retval;
842011fe:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201200:	d8 4c       	rts;

84201202 <$_vol_ctlr_opmsg_obpm_get_status>:
}

bool vol_ctlr_opmsg_obpm_get_status(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201202:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
84201204:	19 09       	r7 = r1 + Null;
84201206:	27 00       	r5 = r2 + Null;
84201208:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
8420120a:	ef fd f9 ff 	call (m) 0x4e6;
8420120e:	3d e6 
84201210:	12 09       	r8 = r0 + Null;
}

bool vol_ctlr_opmsg_obpm_get_status(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    vol_ctrl_gains_t *lpvols = op_extra_data->lpvols;
84201212:	a6 f0 62 88 	r4 = M[r8 + 392];
    unsigned  *resp;

    patch_fn_shared(volume_control_wrapper);

    if(!common_obpm_status_helper(message_data,resp_length,resp_data,sizeof(VOL_CTRL_STATISTICS),&resp))
84201216:	c1 11       	rMAC = FP + 28;
84201218:	09 1c       	pushm <rMAC>;
8420121a:	05 f0 50 40 	r3 = Null + 80;
8420121e:	44 08       	r2 = r6 + Null;
84201220:	3b 00       	r1 = r5 + Null;
84201222:	4a 08       	r0 = r7 + Null;
84201224:	ef fd fc ff 	call (m) 0xb64;
84201228:	21 ea 
8420122a:	7f 4c       	SP = SP + -4;
8420122c:	10 04       	Null = r0 - Null;
8420122e:	03 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_get_status_3;

84201230 <Lc_vol_ctlr_opmsg_obpm_get_status_2>:
    {
        return FALSE;
84201230:	02 00       	r0 = Null + Null;
84201232:	4c 6e       	jump (m) Lc_vol_ctlr_opmsg_obpm_get_status_6;

84201234 <Lc_vol_ctlr_opmsg_obpm_get_status_3>:
    }

    if (resp)
84201234:	3c d8       	r2 = M[FP + 28];
84201236:	49 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_get_status_5;

84201238 <Lc_vol_ctlr_opmsg_obpm_get_status_4>:
    {
        resp = cpsPack2Words(op_extra_data->Ovr_Control, op_extra_data->post_gain, resp);
84201238:	a3 f0 3d 88 	r1 = M[r8 + 244];
8420123c:	a2 f0 3c 88 	r0 = M[r8 + 240];
84201240:	ff fd c5 f1 	call (m) 0x39caa;
84201244:	2b e3 
84201246:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->master_gain, lpvols->auxiliary_gain[0], resp);
84201248:	3c d8       	r2 = M[FP + 28];
8420124a:	b3 88       	r1 = M[r4 + 8];
8420124c:	32 e8       	r0 = M[r4 + Null];
8420124e:	ff fd c5 f1 	call (m) 0x39caa;
84201252:	3d e2 
84201254:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->auxiliary_gain[1], lpvols->auxiliary_gain[2], resp);
84201256:	3c d8       	r2 = M[FP + 28];
84201258:	33 89       	r1 = M[r4 + 16];
8420125a:	f2 88       	r0 = M[r4 + 12];
8420125c:	ff fd c5 f1 	call (m) 0x39caa;
84201260:	2f e2 
84201262:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->auxiliary_gain[3], lpvols->auxiliary_gain[4], resp);
84201264:	3c d8       	r2 = M[FP + 28];
84201266:	b3 89       	r1 = M[r4 + 24];
84201268:	72 89       	r0 = M[r4 + 20];
8420126a:	ff fd c5 f1 	call (m) 0x39caa;
8420126e:	21 e2 
84201270:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->auxiliary_gain[5], lpvols->auxiliary_gain[6], resp);
84201272:	3c d8       	r2 = M[FP + 28];
84201274:	33 98       	r1 = M[r4 + 32];
84201276:	f2 89       	r0 = M[r4 + 28];
84201278:	ff fd c5 f1 	call (m) 0x39caa;
8420127c:	33 e1 
8420127e:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->auxiliary_gain[7], lpvols->channel_trims[0], resp);
84201280:	3c d8       	r2 = M[FP + 28];
84201282:	b3 98       	r1 = M[r4 + 40];
84201284:	72 98       	r0 = M[r4 + 36];
84201286:	ff fd c5 f1 	call (m) 0x39caa;
8420128a:	25 e1 
8420128c:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->channel_trims[1], lpvols->channel_trims[2], resp);
8420128e:	3c d8       	r2 = M[FP + 28];
84201290:	33 99       	r1 = M[r4 + 48];
84201292:	f2 98       	r0 = M[r4 + 44];
84201294:	ff fd c5 f1 	call (m) 0x39caa;
84201298:	37 e0 
8420129a:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->channel_trims[3], lpvols->channel_trims[4], resp);
8420129c:	3c d8       	r2 = M[FP + 28];
8420129e:	b3 99       	r1 = M[r4 + 56];
842012a0:	72 99       	r0 = M[r4 + 52];
842012a2:	ff fd c5 f1 	call (m) 0x39caa;
842012a6:	29 e0 
842012a8:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->channel_trims[5], lpvols->channel_trims[6], resp);
842012aa:	3c d8       	r2 = M[FP + 28];
842012ac:	33 a8       	r1 = M[r4 + 64];
842012ae:	f2 99       	r0 = M[r4 + 60];
842012b0:	ff fd c4 f1 	call (m) 0x39caa;
842012b4:	3b ef 
842012b6:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->channel_trims[7], op_extra_data->aux_state, resp);
842012b8:	3c d8       	r2 = M[FP + 28];
842012ba:	a3 f0 b9 88 	r1 = M[r8 + 740];
842012be:	72 a8       	r0 = M[r4 + 68];
842012c0:	ff fd c4 f1 	call (m) 0x39caa;
842012c4:	2b ef 
842012c6:	3a de       	M[FP + 28] = r0;

842012c8 <Lc_vol_ctlr_opmsg_obpm_get_status_5>:
    }

    return TRUE;
842012c8:	42 20       	r0 = Null + 1;

842012ca <Lc_vol_ctlr_opmsg_obpm_get_status_6>:
}
842012ca:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
842012cc:	d8 4c       	rts;

842012ce <$_vol_ctlr_opmsg_set_ucid>:

    return TRUE;
}

bool vol_ctlr_opmsg_set_ucid(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842012ce:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842012d0:	11 09       	r7 = r0 + Null;
842012d2:	1a 09       	r8 = r1 + Null;
842012d4:	27 00       	r5 = r2 + Null;
842012d6:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842012d8:	ef fd f9 ff 	call (m) 0x4e6;
842012dc:	2f e0 
842012de:	16 00       	r4 = r0 + Null;
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    PS_KEY_TYPE key;
    bool retval;

    retval = cpsSetUcidMsgHandler(&op_extra_data->parms_def,message_data,resp_length,resp_data);
842012e0:	62 f0 b4 22 	r0 = r4 + 692;
842012e4:	45 08       	r3 = r6 + Null;
842012e6:	3c 00       	r2 = r5 + Null;
842012e8:	53 08       	r1 = r8 + Null;
842012ea:	ef fd fb ff 	call (m) 0x9a6;
842012ee:	3d e5 
842012f0:	17 00       	r5 = r0 + Null;

    key = MAP_CAPID_UCID_SBID_TO_PSKEYID(base_op_get_cap_id(op_data),op_extra_data->parms_def.ucid,OPMSG_P_STORE_PARAMETER_SUB_ID);
842012f2:	4a 08       	r0 = r7 + Null;
842012f4:	ef fd f8 ff 	call (m) 0x4ea;
842012f8:	37 ef 
842012fa:	92 c6       	r0 = r0 AND 0xffff;
842012fc:	61 f0 b1 88 	rMAC = M[r4 + 708];
84201300:	92 55       	r0 = r0 LSHIFT 7;
84201302:	8b c2       	r1 = rMAC AND 0x3f;
84201304:	1b 54       	r1 = r1 LSHIFT 1;
84201306:	9b 12       	r1 = r1 OR r0;
    ps_entry_read((void*)op_data,key,PERSIST_ANY,ups_params_vc);
84201308:	42 f0 05 f0 	r3 = Null + 69212469;
8420130c:	35 71 
8420130e:	04 00       	r2 = Null + Null;
84201310:	4a 08       	r0 = r7 + Null;
84201312:	ff fd 32 f0 	call (m) 0x7888;
84201316:	37 eb 

    return retval;
84201318:	3a 00       	r0 = r5 + Null;

8420131a <Lc_vol_ctlr_opmsg_set_ucid_2>:
}
8420131a:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
8420131c:	d8 4c       	rts;

8420131e <$_vol_ctlr_opmsg_get_ps_id>:

bool vol_ctlr_opmsg_get_ps_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420131e:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84201320:	16 00       	r4 = r0 + Null;
84201322:	1a 09       	r8 = r1 + Null;
84201324:	20 09       	r6 = r2 + Null;
84201326:	2f 00       	r5 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201328:	ef fd f8 ff 	call (m) 0x4e6;
8420132c:	3f ed 
8420132e:	11 09       	r7 = r0 + Null;

bool vol_ctlr_opmsg_get_ps_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    return cpsGetUcidMsgHandler(&op_extra_data->parms_def,base_op_get_cap_id(op_data),message_data,resp_length,resp_data);
84201330:	32 00       	r0 = r4 + Null;
84201332:	ef fd f8 ff 	call (m) 0x4ea;
84201336:	39 ed 
84201338:	13 00       	r1 = r0 + Null;
8420133a:	39 1c       	pushm <r5>;
8420133c:	92 f0 b4 22 	r0 = r7 + 692;
84201340:	45 08       	r3 = r6 + Null;
84201342:	54 08       	r2 = r8 + Null;
84201344:	ef fd fb ff 	call (m) 0x9c8;
84201348:	25 e4 
8420134a:	7f 4c       	SP = SP + -4;

8420134c <Lc_vol_ctlr_opmsg_get_ps_id_2>:
}
8420134c:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
8420134e:	d8 4c       	rts;

84201350 <$_vol_ctlr_opmsg_set_sample_rate>:

bool vol_ctlr_opmsg_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201350:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201352:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201354:	ef fd f8 ff 	call (m) 0x4e6;
84201358:	33 ec 
bool vol_ctlr_opmsg_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    /* We received client ID, length and then opmsgID and OBPM params */
    op_extra_data->sample_rate = 25 * (OPMSG_FIELD_GET(message_data, OPMSG_COMMON_MSG_SET_SAMPLE_RATE, SAMPLE_RATE));
8420135a:	f1 88       	rMAC = M[r4 + 12];
8420135c:	89 c6       	rMAC = rMAC AND 0xffff;
8420135e:	49 46       	rMAC = rMAC * 25 (int);
84201360:	21 f0 3b 8e 	M[r0 + 236] = rMAC;

    return TRUE;
84201364:	42 20       	r0 = Null + 1;

84201366 <Lc_vol_ctlr_opmsg_set_sample_rate_2>:
}
84201366:	f1 48       	popm <FP, r4, rLink>;
84201368:	d8 4c       	rts;

8420136a <$_vol_ctlr_opmsg_data_stream_based>:

bool vol_ctlr_opmsg_data_stream_based(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420136a:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420136c:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
8420136e:	ef fd f8 ff 	call (m) 0x4e6;
84201372:	39 eb 
bool vol_ctlr_opmsg_data_stream_based(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    /* We received client ID, length and then opmsgID and OBPM params */
    op_extra_data->stream_based = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_MSG_SET_DATA_STREAM_BASED, IS_STREAM_BASED);
84201374:	f1 88       	rMAC = M[r4 + 12];
84201376:	89 c6       	rMAC = rMAC AND 0xffff;
84201378:	21 f0 c3 8e 	M[r0 + 780] = rMAC;

    return TRUE;
8420137c:	42 20       	r0 = Null + 1;

8420137e <Lc_vol_ctlr_opmsg_data_stream_based_2>:
}
8420137e:	f1 48       	popm <FP, r4, rLink>;
84201380:	d8 4c       	rts;

84201382 <$_vol_ctlr_opmsg_set_buffer_size>:
 * get_buffer_details call, which is part of connecting a terminal.
 * Different sizes can thus be set for each source terminal by
 * calling set_buffer_size before each connection.
 */
bool vol_ctlr_opmsg_set_buffer_size(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201382:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201384:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201386:	ef fd f8 ff 	call (m) 0x4e6;
8420138a:	21 eb 
    patch_fn_shared(volume_control_wrapper);

    unsigned buffer_size_config =
            OPMSG_FIELD_GET( message_data,
                             OPMSG_COMMON_SET_BUFFER_SIZE,
                             BUFFER_SIZE);
8420138c:	f1 88       	rMAC = M[r4 + 12];
8420138e:	89 c6       	rMAC = rMAC AND 0xffff;

    op_extra_data->main_buffer_size_cfg = buffer_size_config;

    if (buffer_size_config != 0)
84201390:	21 f0 d3 8e 	M[r0 + 844] = rMAC;
84201394:	0a 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_buffer_size_4;

84201396 <Lc_vol_ctlr_opmsg_set_buffer_size_2>:
    {
        /* Make aux buffer size larger than main buffer size by
         * an implied resampler block size, 48000/8000 = 6.
         */
        buffer_size_config += VOL_CTRL_BUFFER_SIZE_PROVISION;
84201396:	89 21       	rMAC = rMAC + 6;
        if (op_extra_data->sample_rate > 48000)
84201398:	23 f0 3b 88 	r1 = M[r0 + 236];
8420139c:	02 f0 30 f3 	Null = r1 - 48000;
842013a0:	80 37 
842013a2:	09 f0 87 e0 	if LS jump (m) Lc_vol_ctlr_opmsg_set_buffer_size_4;

842013a6 <Lc_vol_ctlr_opmsg_set_buffer_size_3>:
        {
            /* Double this implicit block size assumption for fs = 88.2k / 96k */
            buffer_size_config += VOL_CTRL_BUFFER_SIZE_PROVISION;
842013a6:	89 21       	rMAC = rMAC + 6;

842013a8 <Lc_vol_ctlr_opmsg_set_buffer_size_4>:
        }
    }
    op_extra_data->aux_buffer_size_cfg = buffer_size_config;
842013a8:	21 f0 d4 8e 	M[r0 + 848] = rMAC;

    return TRUE;
842013ac:	42 20       	r0 = Null + 1;

842013ae <Lc_vol_ctlr_opmsg_set_buffer_size_5>:
}
842013ae:	f1 48       	popm <FP, r4, rLink>;
842013b0:	d8 4c       	rts;

842013b2 <$_vol_ctlr_opmsg_set_terminal_buffer_size>:
 * The message is the standard OPMSG_COMMON_SET_TERMINAL_BUFFER_SIZE.
 * The operator accepts it at any time. It is applied to terminals
 * in two groups: aux inputs and main inputs/outputs.
 */
bool vol_ctlr_opmsg_set_terminal_buffer_size(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842013b2:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842013b4:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842013b6:	ef fd f8 ff 	call (m) 0x4e6;
842013ba:	31 e9 
    patch_fn_shared(volume_control_wrapper);

    int buffer_size_config =
            OPMSG_FIELD_GET( message_data,
                             OPMSG_COMMON_SET_TERMINAL_BUFFER_SIZE,
                             BUFFER_SIZE);
842013bc:	f1 88       	rMAC = M[r4 + 12];
842013be:	89 c6       	rMAC = rMAC AND 0xffff;

    unsigned sinks = OPMSG_FIELD_GET( message_data,
                             OPMSG_COMMON_SET_TERMINAL_BUFFER_SIZE,
                             SINKS);
842013c0:	33 89       	r1 = M[r4 + 16];
842013c2:	9b c6       	r1 = r1 AND 0xffff;
    unsigned sources = OPMSG_FIELD_GET( message_data,
                             OPMSG_COMMON_SET_TERMINAL_BUFFER_SIZE,
                             SOURCES);
842013c4:	74 89       	r2 = M[r4 + 20];
842013c6:	a4 c6       	r2 = r2 AND 0xffff;

    if (((sinks & VOL_CTRL_MAIN_INPUT_TERM_MASK) != 0) ||
        ((sources & VOL_CTRL_MAIN_OUTPUT_TERM_MASK) != 0))
842013c8:	35 f2 55 15 	r3 = r1 AND 0x5555;
842013cc:	03 62       	if NE jump (m) Lc_vol_ctlr_opmsg_set_terminal_buffer_size_3;

842013ce <Lc_vol_ctlr_opmsg_set_terminal_buffer_size_2>:
842013ce:	a4 c3       	r2 = r2 AND 0xff;
842013d0:	03 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_terminal_buffer_size_4;

842013d2 <Lc_vol_ctlr_opmsg_set_terminal_buffer_size_3>:
    {
        op_extra_data->main_buffer_size_cfg = buffer_size_config;
842013d2:	21 f0 d3 8e 	M[r0 + 844] = rMAC;

842013d6 <Lc_vol_ctlr_opmsg_set_terminal_buffer_size_4>:
    }
    if ((sinks & VOL_CTRL_AUX_INPUT_TERM_MASK) != 0)
842013d6:	33 f5 aa 0a 	r1 = r1 AND 0xaaaa;
842013da:	03 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_terminal_buffer_size_6;

842013dc <Lc_vol_ctlr_opmsg_set_terminal_buffer_size_5>:
    {
        op_extra_data->aux_buffer_size_cfg = buffer_size_config;
842013dc:	21 f0 d4 8e 	M[r0 + 848] = rMAC;

842013e0 <Lc_vol_ctlr_opmsg_set_terminal_buffer_size_6>:
    }

    return TRUE;
842013e0:	42 20       	r0 = Null + 1;

842013e2 <Lc_vol_ctlr_opmsg_set_terminal_buffer_size_7>:
}
842013e2:	f1 48       	popm <FP, r4, rLink>;
842013e4:	d8 4c       	rts;

842013e6 <$_vol_ctlr_opmsg_set_aux_time_to_play>:

    return TRUE;
}
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
bool vol_ctlr_opmsg_set_aux_time_to_play(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842013e6:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
842013e8:	11 09       	r7 = r0 + Null;
842013ea:	1f 00       	r5 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842013ec:	ef fd f8 ff 	call (m) 0x4e6;
842013f0:	3b e7 
842013f2:	16 00       	r4 = r0 + Null;


    /* get aux channel index */
    unsigned aux_channel_index = OPMSG_FIELD_GET(message_data,
                                                 OPMSG_VOL_CTRL_SET_AUX_TIME_TO_PLAY,
                                                 AUX_CHANNEL_INDEX);
842013f4:	f9 88       	rMAC = M[r5 + 12];
842013f6:	8b c6       	r1 = rMAC AND 0xffff;
        (TIME)OPMSG_FIELD_GET_FROM_OFFSET(message_data,
                                          OPMSG_VOL_CTRL_SET_AUX_TIME_TO_PLAY,
                                          AUX_TIME_TO_PLAY, 1) +
        ((TIME)OPMSG_FIELD_GET_FROM_OFFSET(message_data,
                                           OPMSG_VOL_CTRL_SET_AUX_TIME_TO_PLAY,
                                          AUX_TIME_TO_PLAY, 0) << 16);
842013f8:	39 89       	rMAC = M[r5 + 16];
842013fa:	8a c6       	r0 = rMAC AND 0xffff;
842013fc:	92 56       	r0 = r0 LSHIFT 16;
842013fe:	79 89       	rMAC = M[r5 + 20];
84201400:	89 c6       	rMAC = rMAC AND 0xffff;
84201402:	1f f2 08 c0 	r6 = r0 + rMAC;
    /* get drift rate */
    int aux_drift_rate = (int)(int16)OPMSG_FIELD_GET(message_data,
                                                     OPMSG_VOL_CTRL_SET_AUX_TIME_TO_PLAY,
                                                     AUX_DRIFT_RATE);
84201406:	b9 89       	rMAC = M[r5 + 24];
84201408:	0f 0c       	r5 = SE16 rMAC;

    /* Only channel 0 is supported */
    if(aux_channel_index != 0)
8420140a:	18 04       	Null = r1 - Null;
8420140c:	0d 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_5;

8420140e <Lc_vol_ctlr_opmsg_set_aux_time_to_play_2>:
    {
        L2_DBG_MSG1("Volume Control Aux Timed Playback, "
                    "only channel 0 supports this feature, channel=%d",
                    aux_channel_index);
8420140e:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84201412:	88 24       	Null = rMAC - 2;
84201414:	07 68       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

84201416 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_3>:
84201416:	55 f1 02 f0 	r0 = Null + 357564774;
8420141a:	66 41 
8420141c:	ef fd fc ff 	call (m) 0xcde;
84201420:	23 e6 

84201422 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_4>:
        return FALSE;
84201422:	02 00       	r0 = Null + Null;
84201424:	76 6e       	jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_17;

84201426 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_5>:
    }

    /* drift_rate is in 1/10 of ppm, so convert it to a
     * fractional number.
     */
    aux_drift_rate = aux_drift_rate * FRACTIONAL(0.0001);
84201426:	46 f3 dc f7 	r5 = r5 * 214748 (int);
8420142a:	97 d9 
    aux_drift_rate = frac_mult(aux_drift_rate, FRACTIONAL(0.001));
8420142c:	02 f0 62 f0 	r0 = Null + 2147483;
84201430:	9b 48 
84201432:	00 f2 77 c9 	r5 = r5 * r0 (frac);

    vol_ctrl_aux_channel_t  *aux_channel = &op_extra_data->aux_channel[aux_channel_index];
84201436:	61 f0 6c 20 	rMAC = r4 + 108;
     * if sent after that we aren't be able to meet the deadline for timed
     * playback so just return FALSE.
     */
    if(aux_channel->buffer != NULL &&
       aux_channel->state != AUX_STATE_NO_AUX &&
       aux_channel->state != AUX_STATE_END_AUX)
8420143a:	0a e8       	r0 = M[rMAC + Null];
8420143c:	11 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_10;

8420143e <Lc_vol_ctlr_opmsg_set_aux_time_to_play_6>:
8420143e:	09 81       	rMAC = MBS[rMAC + 4];
84201440:	0f 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_10;

84201442 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_7>:
84201442:	c8 24       	Null = rMAC - 3;
84201444:	0d 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_10;

84201446 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_8>:
    {
        L2_DBG_MSG1("Volume Control Aux Timed Playback: "
                    "aux channel %d is already active",
                    aux_channel_index);
84201446:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420144a:	88 24       	Null = rMAC - 2;
8420144c:	eb 69       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

8420144e <Lc_vol_ctlr_opmsg_set_aux_time_to_play_9>:
8420144e:	55 f1 02 f0 	r0 = Null + 357564858;
84201452:	ba 41 
84201454:	03 00       	r1 = Null + Null;
84201456:	ef fd fc ff 	call (m) 0xcde;
8420145a:	29 e4 
8420145c:	e3 6f       	jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

8420145e <Lc_vol_ctlr_opmsg_set_aux_time_to_play_10>:
        return FALSE;
    }

    /* Sanity check on time to play time */
    TIME current_time = time_get_time();
8420145e:	ff fd 26 f0 	call (m) 0x6100;
84201462:	23 e5 
84201464:	13 00       	r1 = r0 + Null;
    TIME_INTERVAL ttp_in_future = time_sub(aux_time_to_play, current_time);
84201466:	3f f8 01 c2 	rMAC = r6 - r1;
    if(ttp_in_future < (VOL_CTRL_AUX_MIN_TTP_IN_FUTURE_MS*MILLISECOND) ||
       ttp_in_future > (VOL_CTRL_AUX_MAX_TTP_IN_FUTURE_MS*MILLISECOND))
8420146a:	01 f0 10 f3 	Null = rMAC - 30000;
8420146e:	30 2d 
84201470:	05 68       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_12;

84201472 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_11>:
84201472:	c4 f4 10 f2 	Null = rMAC - 20000000;
84201476:	00 3d 
84201478:	0d 6c       	if LE jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_14;

8420147a <Lc_vol_ctlr_opmsg_set_aux_time_to_play_12>:
    {
        L2_DBG_MSG2("Volume Control Aux Timed Playback: "
                    "Requested time to play is too early or too late,"
                    "current time=%d, time to play=%d",
                    current_time, aux_time_to_play);
8420147a:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420147e:	88 24       	Null = rMAC - 2;
84201480:	d1 69       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

84201482 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_13>:
84201482:	55 f1 02 f0 	r0 = Null + 357564926;
84201486:	fe 41 
84201488:	44 08       	r2 = r6 + Null;
8420148a:	ef fd fc ff 	call (m) 0xcf2;
8420148e:	29 e3 
84201490:	c9 6f       	jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

84201492 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_14>:
     * aux_time_to_play will be for first sample of aux,
     * we have a ramping down time for main channel before
     * actual mixing happens.
     * */
    vol_ctrl_aux_params_t *aux_param = (vol_ctrl_aux_params_t *)
        (&op_extra_data->parameters.OFFSET_AUX1_SCALE);
84201492:	61 f0 94 21 	rMAC = r4 + 404;
    unsigned atk_tc = aux_param[aux_channel_index].atk_tc;
84201496:	4b 88       	r1 = M[rMAC + 4];
    TIME_INTERVAL start_period = (TIME_INTERVAL) ((1<<(DAWTH-1))/atk_tc)*10;
84201498:	00 f8 02 f0 	r0 = Null + -2147483648;
8420149c:	00 40 
8420149e:	ff fd c6 f0 	call (m) 0x1a290;
842014a2:	33 ef 
842014a4:	91 42       	rMAC = r0 * 10 (int);
    TIME ttp_gate_time = time_sub(aux_time_to_play, start_period);
842014a6:	1f f8 0b c2 	r9 = r6 - rMAC;
    /* aux timed playback message in only for one tone/prompt,
     * if we don't receive the actual aux data within reasonable
     * time, timed playback will expire and later received aux data
     * will be mixed in normal non-ttp mode */
    TIME ttp_expiry_time = time_add(aux_time_to_play,
                                    VOL_CTRL_AUX_TTP_EXPIRY_PERIOD_MS*MILLISECOND);
842014aa:	06 f0 8a f0 	r8 = r6 + 100000;
842014ae:	a0 2a 

    L2_DBG_MSG4("Volume Control, setting auxiliary playback time:"
                " time=%d, channel=%d, ttp=%d, drift=%d",
                time_get_time(), aux_channel_index, aux_time_to_play, aux_drift_rate);
842014b0:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842014b4:	88 24       	Null = rMAC - 2;
842014b6:	0f 68       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_16;

842014b8 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_15>:
842014b8:	ff fd 26 f0 	call (m) 0x6100;
842014bc:	29 e2 
842014be:	13 00       	r1 = r0 + Null;
842014c0:	39 1c       	pushm <r5>;
842014c2:	55 f1 02 f0 	r0 = Null + 357565042;
842014c6:	72 42 
842014c8:	04 00       	r2 = Null + Null;
842014ca:	45 08       	r3 = r6 + Null;
842014cc:	ef fd fc ff 	call (m) 0xd20;
842014d0:	35 e2 
842014d2:	7f 4c       	SP = SP + -4;

842014d4 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_16>:
    /* postpone processing just in case this update is preempted
     * by the operator's process. Normally user is expected to send
     * this message before auxiliary path starts sending audio data,
     * so practically perhaps not required.
     */
    opmgr_op_suspend_processing(op_data);
842014d4:	4a 08       	r0 = r7 + Null;
842014d6:	ff fd 21 f0 	call (m) 0x570c;
842014da:	37 e1 
    op_extra_data->aux0_ttp.time_to_play = aux_time_to_play;
842014dc:	68 f0 c5 8e 	M[r4 + 788] = r6;
    op_extra_data->aux0_ttp.expiry_time = ttp_expiry_time;
842014e0:	6a f0 c6 8e 	M[r4 + 792] = r8;
    op_extra_data->aux0_ttp.gate_time = ttp_gate_time;
842014e4:	6b f0 c7 8e 	M[r4 + 796] = r9;
    op_extra_data->aux0_ttp.drift_rate = aux_drift_rate;
842014e8:	67 f0 c9 8e 	M[r4 + 804] = r5;
    op_extra_data->aux0_ttp.enabled = TRUE;
842014ec:	41 20       	rMAC = Null + 1;
842014ee:	61 f0 c4 8e 	M[r4 + 784] = rMAC;

#ifdef VOLUME_CONTROL_AUX_TIMING_TRACE
    record_aux_ttr_event(op_data,
                         VOL_CTRL_TTR_EVENT_AUX_STATE,
                         pack_aux_state(op_extra_data),
                         aux_time_to_play);
842014f2:	32 00       	r0 = r4 + Null;
842014f4:	01 f0 3d ef 	call (m) Lc_pack_aux_state_1;
842014f8:	03 f0 44 40 	r1 = Null + 68;
842014fc:	45 08       	r3 = r6 + Null;
842014fe:	14 00       	r2 = r0 + Null;
84201500:	4a 08       	r0 = r7 + Null;
84201502:	02 f0 31 e0 	call (m) Lc_record_aux_ttr_event_1;
#endif /* VOLUME_CONTROL_AUX_TIMING_TRACE */
    opmgr_op_resume_processing(op_data);
84201506:	4a 08       	r0 = r7 + Null;
84201508:	ff fd 21 f0 	call (m) 0x573a;
8420150c:	33 e1 
    return TRUE;
8420150e:	42 20       	r0 = Null + 1;

84201510 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_17>:
}
84201510:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201512:	d8 4c       	rts;

84201514 <$_vol_ctlr_opmsg_set_downstream_latency_est>:

bool vol_ctlr_opmsg_set_downstream_latency_est(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201514:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201516:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201518:	ef fd f7 ff 	call (m) 0x4e6;
8420151c:	2f ee 
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    /* get downstream latency field */
    unsigned latency_est_ms = OPMSG_FIELD_GET(message_data,
                                              OPMSG_VOL_CTRL_SET_DOWNSTREAM_LATENCY_EST,
                                              LATENCY_EST_MS);
8420151e:	f1 88       	rMAC = M[r4 + 12];
84201520:	89 c6       	rMAC = rMAC AND 0xffff;
    /* check maximum value */
    if(latency_est_ms > VOL_CTRL_MAX_DOWNSTREAM_LATENCY_MS)
84201522:	10 f0 c8 24 	Null = rMAC - 200;
84201526:	09 f0 89 e0 	if LS jump (m) Lc_vol_ctlr_opmsg_set_downstream_latency_est_3;

8420152a <Lc_vol_ctlr_opmsg_set_downstream_latency_est_2>:
    {
        return FALSE;
8420152a:	02 00       	r0 = Null + Null;
8420152c:	04 6e       	jump (m) Lc_vol_ctlr_opmsg_set_downstream_latency_est_4;

8420152e <Lc_vol_ctlr_opmsg_set_downstream_latency_est_3>:

    /* set downstream latency config, change while
	   the operator is running is ok, but the value
	   will be used from next auxiliary burst.
	 */
    VOL_CTRL_DOWNSTREAM_LATENCY_EST(op_extra_data) = latency_est_ms;
8420152e:	21 f0 d2 8e 	M[r0 + 840] = rMAC;
    return TRUE;
84201532:	42 20       	r0 = Null + 1;

84201534 <Lc_vol_ctlr_opmsg_set_downstream_latency_est_4>:
}
84201534:	f1 48       	popm <FP, r4, rLink>;
84201536:	d8 4c       	rts;

84201538 <Lc_vol_ctrl_fixup_buffer_details_1>:
 */
static bool vol_ctrl_fixup_buffer_details(VOL_CTRL_DATA_T *op_extra_data, unsigned terminal_id, OP_BUF_DETAILS_RSP *resp)
{
    patch_fn_shared(volume_control_wrapper);

    return TRUE;
84201538:	42 20       	r0 = Null + 1;

8420153a <Lc_vol_ctrl_fixup_buffer_details_2>:
8420153a:	d8 4c       	rts;

8420153c <Lc_vol_ctrl_recalc_main_buffer_size_1>:
8420153c:	d8 4c       	rts;

8420153e <Lc_vol_ctrl_recalc_aux_buffer_size_1>:

/**
 * \brief Update aux_buffer_size with the minimum of connected aux buffers' sizes
 */
static void vol_ctrl_recalc_aux_buffer_size(VOL_CTRL_DATA_T *op_extra_data)
{
8420153e:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84201540:	16 00       	r4 = r0 + Null;
    unsigned ch;
    unsigned aux_buffer_min_size = MAXINT;
84201542:	ff f7 f8 f7 	r6 = Null + 2147483647;
84201546:	ff 7b 

    patch_fn_shared(volume_control_wrapper);

    for (ch = 0; ch < VOL_CTRL_CONSTANT_NUM_CHANNELS; ch += 1)
84201548:	07 00       	r5 = Null + Null;
8420154a:	69 f0 6c 20 	r7 = r4 + 108;

8420154e <Lc_vol_ctrl_recalc_aux_buffer_size_2>:
    {
        tCbuffer* aux_buffer = op_extra_data->aux_channel[ch].buffer;
        if (aux_buffer != NULL)
8420154e:	92 f0 00 e8 	r0 = M[r7 + Null];
84201552:	08 60       	if EQ jump (m) Lc_vol_ctrl_recalc_aux_buffer_size_5;

84201554 <Lc_vol_ctrl_recalc_aux_buffer_size_3>:
        {
            unsigned size = cbuffer_get_size_in_words(aux_buffer);
84201554:	ff fd 97 f0 	call (m) 0x14450;
84201558:	3d e7 
            aux_buffer_min_size = MIN(aux_buffer_min_size, size);
8420155a:	2f f8 00 c2 	Null = r6 - r0;
8420155e:	02 64       	if NC jump (m) Lc_vol_ctrl_recalc_aux_buffer_size_5;

84201560 <Lc_vol_ctrl_recalc_aux_buffer_size_4>:
84201560:	10 09       	r6 = r0 + Null;

84201562 <Lc_vol_ctrl_recalc_aux_buffer_size_5>:
    unsigned ch;
    unsigned aux_buffer_min_size = MAXINT;

    patch_fn_shared(volume_control_wrapper);

    for (ch = 0; ch < VOL_CTRL_CONSTANT_NUM_CHANNELS; ch += 1)
84201562:	7f 20       	r5 = r5 + 1;
84201564:	81 75       	r7 = r7 + 16;
84201566:	38 26       	Null = r5 - 8;
84201568:	f3 65       	if NC jump (m) Lc_vol_ctrl_recalc_aux_buffer_size_2;

8420156a <Lc_vol_ctrl_recalc_aux_buffer_size_6>:
        {
            unsigned size = cbuffer_get_size_in_words(aux_buffer);
            aux_buffer_min_size = MIN(aux_buffer_min_size, size);
        }
    }
    op_extra_data->aux_buff_size = aux_buffer_min_size;
8420156a:	68 f0 bb 8e 	M[r4 + 748] = r6;

8420156e <Lc_vol_ctrl_recalc_aux_buffer_size_7>:
}
8420156e:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201570:	d8 4c       	rts;

84201572 <Lc_vol_ctrl_kick_waiting_1>:
84201572:	d8 4c       	rts;

84201574 <Lc_vol_ctrl_handle_aux_metadata_1>:
 *          delete all other aux metadata
 * \param op_extra_data     volume control operator specific data
 * \returns                 EOF tag, if found
 */
static metadata_tag* vol_ctrl_handle_aux_metadata(VOL_CTRL_DATA_T *op_extra_data)
{
84201574:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
84201576:	17 00       	r5 = r0 + Null;
    metadata_tag* aux_tag_head = NULL;
84201578:	02 00       	r0 = Null + Null;
    metadata_tag* eoftag = NULL;
8420157a:	06 00       	r4 = Null + Null;
    metadata_tag* tmp_tag = NULL;
    metadata_tag* prev_tag = NULL;
8420157c:	00 09       	r6 = Null + Null;
    unsigned b4idx, afteridx;

    /* get aux metadata, if applicable */
    if (op_extra_data->metadata_aux_channel != NULL)
8420157e:	39 a9       	rMAC = M[r5 + 80];
84201580:	09 60       	if EQ jump (m) Lc_vol_ctrl_handle_aux_metadata_3;

84201582 <Lc_vol_ctrl_handle_aux_metadata_2>:
    {
        aux_tag_head = buff_metadata_remove(op_extra_data->metadata_aux_channel->buffer,
                                            op_extra_data->metadata_aux_channel->advance_buffer * OCTETS_PER_SAMPLE,
                                            &b4idx, &afteridx);
84201582:	85 11       	r3 = FP + 24;
84201584:	44 11       	r2 = FP + 20;
84201586:	ca 88       	r0 = M[rMAC + 12];
84201588:	53 54       	r1 = r0 LSHIFT 2;
8420158a:	0a e8       	r0 = M[rMAC + Null];
8420158c:	ff fd 9a f0 	call (m) 0x149ca;
84201590:	3f e1 

84201592 <Lc_vol_ctrl_handle_aux_metadata_3>:
    }

    /* only look for EOF if we could output it */
    if (op_extra_data->metadata_op_buffer != NULL)
84201592:	f9 a8       	rMAC = M[r5 + 76];
84201594:	14 60       	if EQ jump (m) Lc_vol_ctrl_handle_aux_metadata_12;

84201596 <Lc_vol_ctrl_handle_aux_metadata_4>:
    {
        /* search for eof tag in aux metadata */
        tmp_tag = aux_tag_head;
84201596:	11 00       	rMAC = r0 + Null;

84201598 <Lc_vol_ctrl_handle_aux_metadata_5>:
        while (tmp_tag != NULL && !METADATA_STREAM_END(tmp_tag))
84201598:	08 04       	Null = rMAC - Null;
8420159a:	11 60       	if EQ jump (m) Lc_vol_ctrl_handle_aux_metadata_12;

8420159c <Lc_vol_ctrl_handle_aux_metadata_6>:
8420159c:	4b 88       	r1 = M[rMAC + 4];
8420159e:	5b c0       	r1 = r1 AND 0x2;
842015a0:	04 62       	if NE jump (m) Lc_vol_ctrl_handle_aux_metadata_8;

842015a2 <Lc_vol_ctrl_handle_aux_metadata_7>:
        {
            prev_tag = tmp_tag;
842015a2:	08 09       	r6 = rMAC + Null;
            tmp_tag = tmp_tag->next;
842015a4:	09 e8       	rMAC = M[rMAC + Null];
    /* only look for EOF if we could output it */
    if (op_extra_data->metadata_op_buffer != NULL)
    {
        /* search for eof tag in aux metadata */
        tmp_tag = aux_tag_head;
        while (tmp_tag != NULL && !METADATA_STREAM_END(tmp_tag))
842015a6:	f9 6f       	jump (m) Lc_vol_ctrl_handle_aux_metadata_5;

842015a8 <Lc_vol_ctrl_handle_aux_metadata_8>:
            tmp_tag = tmp_tag->next;
        }
        if (tmp_tag != NULL)
        {
            /* EOF tag was found in aux metadata*/
            eoftag = tmp_tag;
842015a8:	0e 00       	r4 = rMAC + Null;
            /* remove it from the list */
            if (prev_tag != NULL)
842015aa:	0f f8 00 c2 	Null = r6 - Null;
842015ae:	05 60       	if EQ jump (m) Lc_vol_ctrl_handle_aux_metadata_10;

842015b0 <Lc_vol_ctrl_handle_aux_metadata_9>:
            {
                prev_tag->next = eoftag->next;
842015b0:	0b e8       	r1 = M[rMAC + Null];
842015b2:	83 f0 00 ee 	M[r6 + Null] = r1;
842015b6:	02 6e       	jump (m) Lc_vol_ctrl_handle_aux_metadata_11;

842015b8 <Lc_vol_ctrl_handle_aux_metadata_10>:
            }
            else
            {
                aux_tag_head = eoftag->next;
842015b8:	0a e8       	r0 = M[rMAC + Null];

842015ba <Lc_vol_ctrl_handle_aux_metadata_11>:
            }
            eoftag->next = NULL;
842015ba:	08 ee       	M[rMAC + Null] = Null;

842015bc <Lc_vol_ctrl_handle_aux_metadata_12>:
        }
    }
    /* delete aux metadata anyways */
    buff_metadata_tag_list_delete(aux_tag_head);
842015bc:	ff fd 98 f0 	call (m) 0x145ee;
842015c0:	33 e1 

    return eoftag;
842015c2:	32 00       	r0 = r4 + Null;

842015c4 <Lc_vol_ctrl_handle_aux_metadata_13>:
}
842015c4:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
842015c6:	d8 4c       	rts;

842015c8 <Lc_vol_ctrl_handle_input_metadata_1>:
 * \brief Transport metadata from input to output and handle aux EOF.
 * \param op_extra_data     volume control operator specific data
 * \param eoftag            EOF tag, if found in aux metadata
 */
static void vol_ctrl_handle_input_metadata(VOL_CTRL_DATA_T *op_extra_data, metadata_tag* eoftag)
{
842015c8:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
842015ca:	16 00       	r4 = r0 + Null;
842015cc:	18 09       	r6 = r1 + Null;
    metadata_tag *ret_mtag;
    metadata_tag* tmp_tag = NULL;
    metadata_tag* prev_tag = NULL;
    unsigned b4idx, afteridx;
    unsigned input_amount = op_extra_data->tc.num_words * OCTETS_PER_SAMPLE;
842015ce:	62 f0 b2 88 	r0 = M[r4 + 712];
842015d2:	01 f2 d9 c8 	r7 = r0 LSHIFT 2;

    /* get input metadata, if applicable*/
    if (op_extra_data->metadata_ip_buffer != NULL)
842015d6:	b2 a8       	r0 = M[r4 + 72];
842015d8:	09 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_3;

842015da <Lc_vol_ctrl_handle_input_metadata_2>:
    {
        ret_mtag = buff_metadata_remove(op_extra_data->metadata_ip_buffer,
                                        input_amount, &b4idx, &afteridx);
842015da:	c5 11       	r3 = FP + 28;
842015dc:	84 11       	r2 = FP + 24;
842015de:	4b 08       	r1 = r7 + Null;
842015e0:	ff fd 99 f0 	call (m) 0x149ca;
842015e4:	2b ef 
842015e6:	17 00       	r5 = r0 + Null;
842015e8:	05 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_4;

842015ea <Lc_vol_ctrl_handle_input_metadata_3>:
    }
    else
    {
        b4idx = 0;
842015ea:	30 de       	M[FP + 24] = Null;
        afteridx = input_amount;
842015ec:	e9 f0 07 8e 	M[FP + 28] = r7;
        ret_mtag = NULL;
842015f0:	07 00       	r5 = Null + Null;

842015f2 <Lc_vol_ctrl_handle_input_metadata_4>:
    }

    if (op_extra_data->metadata_op_buffer != NULL)
842015f2:	f1 a8       	rMAC = M[r4 + 76];
842015f4:	78 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_36;

842015f6 <Lc_vol_ctrl_handle_input_metadata_5>:
    {
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
        if(op_extra_data->aux0_ttp.generate_ttp)
842015f6:	60 f0 c8 88 	Null = M[r4 + 800];
842015fa:	06 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_7;

842015fc <Lc_vol_ctrl_handle_input_metadata_6>:
        {
            /* Operator shall generate timestamp itself, this
             * is done by time-stamping VOID tags.
             */
            vol_ctrl_timestamp_void_tags(op_extra_data, ret_mtag, b4idx);
842015fc:	34 d8       	r2 = M[FP + 24];
842015fe:	3b 00       	r1 = r5 + Null;
84201600:	32 00       	r0 = r4 + Null;
84201602:	01 f0 21 e2 	call (m) Lc_vol_ctrl_timestamp_void_tags_1;

84201606 <Lc_vol_ctrl_handle_input_metadata_7>:
        }
#endif
        if (ret_mtag == NULL)
84201606:	38 04       	Null = r5 - Null;
84201608:	31 62       	if NE jump (m) Lc_vol_ctrl_handle_input_metadata_19;

8420160a <Lc_vol_ctrl_handle_input_metadata_8>:
            /* No metadata in input: we cannot append EOF tags!
             * In this case we need to save the EOF tag until
             * a new input tag comes in.
             * If none does, we need to recognise the data closing
             * the last received tag and append the EOF there. */
            if (eoftag != NULL)
8420160a:	0f f8 00 c2 	Null = r6 - Null;
8420160e:	12 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_13;

84201610 <Lc_vol_ctrl_handle_input_metadata_9>:
            {
                /* Save it for next run. */
                if (op_extra_data->last_eoftag != NULL)
84201610:	72 a9       	r0 = M[r4 + 84];
84201612:	04 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_11;

84201614 <Lc_vol_ctrl_handle_input_metadata_10>:
                {
                    /* We already had a pending EOF tag. Delete it. */
                    buff_metadata_tag_list_delete(op_extra_data->last_eoftag);
84201614:	ff fd 97 f0 	call (m) 0x145ee;
84201618:	3b ee 

8420161a <Lc_vol_ctrl_handle_input_metadata_11>:
                }
                op_extra_data->last_eoftag = eoftag;
8420161a:	68 f0 15 8e 	M[r4 + 84] = r6;
                L2_DBG_MSG("volume_control: aux EOF saved for next run");
8420161e:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84201622:	88 24       	Null = rMAC - 2;
84201624:	07 68       	if LT jump (m) Lc_vol_ctrl_handle_input_metadata_13;

84201626 <Lc_vol_ctrl_handle_input_metadata_12>:
84201626:	55 f1 02 f0 	r0 = Null + 357564416;
8420162a:	00 40 
8420162c:	ef fd fb ff 	call (m) 0xccc;
84201630:	21 e5 

84201632 <Lc_vol_ctrl_handle_input_metadata_13>:
            }
            if (op_extra_data->last_tag_data_remaining <= input_amount)
84201632:	b1 a9       	rMAC = M[r4 + 88];
84201634:	9f f1 00 c2 	Null = rMAC - r7;
84201638:	08 f0 ab e0 	if HI jump (m) Lc_vol_ctrl_handle_input_metadata_18;

8420163c <Lc_vol_ctrl_handle_input_metadata_14>:
            {
                /* The last received tag is closed now and no other tags
                 * came through. If we had a pending EOF tag,
                 * we need to output it now */
                if (op_extra_data->last_eoftag != NULL)
8420163c:	71 a9       	rMAC = M[r4 + 84];
8420163e:	10 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_17;

84201640 <Lc_vol_ctrl_handle_input_metadata_15>:
                {
                    ret_mtag = op_extra_data->last_eoftag;
84201640:	0f 00       	r5 = rMAC + Null;
                    /* clear backup ptr */
                    op_extra_data->last_eoftag = NULL;
84201642:	70 af       	M[r4 + 84] = Null;
                    b4idx = input_amount;
84201644:	e9 f0 06 8e 	M[FP + 24] = r7;
                    afteridx = 0;
84201648:	38 de       	M[FP + 28] = Null;
                    L2_DBG_MSG("volume_control: ORPHAN aux EOF moved to output");
8420164a:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420164e:	88 24       	Null = rMAC - 2;
84201650:	07 68       	if LT jump (m) Lc_vol_ctrl_handle_input_metadata_17;

84201652 <Lc_vol_ctrl_handle_input_metadata_16>:
84201652:	55 f1 02 f0 	r0 = Null + 357564459;
84201656:	2b 40 
84201658:	ef fd fb ff 	call (m) 0xccc;
8420165c:	35 e3 

8420165e <Lc_vol_ctrl_handle_input_metadata_17>:
                }
                op_extra_data->last_tag_data_remaining = 0;
8420165e:	b0 af       	M[r4 + 88] = Null;
84201660:	3a 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_35;

84201662 <Lc_vol_ctrl_handle_input_metadata_18>:
            }
            else
            {
                /* update the number of octets to come to complete the last tag */
                op_extra_data->last_tag_data_remaining -= input_amount;
84201662:	00 f9 31 c2 	rMAC = rMAC - r7;
84201666:	b1 af       	M[r4 + 88] = rMAC;
84201668:	36 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_35;

8420166a <Lc_vol_ctrl_handle_input_metadata_19>:
        }
        else
        {
            /* Check if we found an EOF on a previous run where input had no
             * metadata and we could not append it on the output. */
            if (op_extra_data->last_eoftag != NULL && ret_mtag != NULL)
8420166a:	71 a9       	rMAC = M[r4 + 84];
8420166c:	0e 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_22;

8420166e <Lc_vol_ctrl_handle_input_metadata_20>:
            {
                /* Transport now at the beginning of the output*/
                op_extra_data->last_eoftag->next = ret_mtag;
8420166e:	0f ee       	M[rMAC + Null] = r5;
                ret_mtag = op_extra_data->last_eoftag;
84201670:	77 a9       	r5 = M[r4 + 84];
                /* clear backup ptr */
                op_extra_data->last_eoftag = NULL;
84201672:	70 af       	M[r4 + 84] = Null;
                L2_DBG_MSG("volume_control: previous aux EOF moved to output");
84201674:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84201678:	88 24       	Null = rMAC - 2;
8420167a:	07 68       	if LT jump (m) Lc_vol_ctrl_handle_input_metadata_22;

8420167c <Lc_vol_ctrl_handle_input_metadata_21>:
8420167c:	55 f1 02 f0 	r0 = Null + 357564506;
84201680:	5a 40 
84201682:	ef fd fb ff 	call (m) 0xccc;
84201686:	2b e2 

84201688 <Lc_vol_ctrl_handle_input_metadata_22>:
            }

            /* find the last tag of input metadata */
            tmp_tag = ret_mtag;
84201688:	3a 00       	r0 = r5 + Null;
            prev_tag = NULL;
8420168a:	01 00       	rMAC = Null + Null;

8420168c <Lc_vol_ctrl_handle_input_metadata_23>:
            while (tmp_tag->next != NULL)
8420168c:	13 e8       	r1 = M[r0 + Null];
8420168e:	04 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_25;

84201690 <Lc_vol_ctrl_handle_input_metadata_24>:
            {
                prev_tag = tmp_tag;
84201690:	11 00       	rMAC = r0 + Null;
                tmp_tag = tmp_tag->next;
84201692:	1a 00       	r0 = r1 + Null;
84201694:	fc 6f       	jump (m) Lc_vol_ctrl_handle_input_metadata_23;

84201696 <Lc_vol_ctrl_handle_input_metadata_25>:
            }

            /* save the number of octets to come to complete the last tag*/
            if (afteridx > 0 && afteridx <= tmp_tag->length)
84201696:	3b d8       	r1 = M[FP + 28];
84201698:	08 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_28;

8420169a <Lc_vol_ctrl_handle_input_metadata_26>:
8420169a:	d4 88       	r2 = M[r0 + 12];
8420169c:	18 05       	Null = r1 - r2;
8420169e:	08 f0 8b e0 	if HI jump (m) Lc_vol_ctrl_handle_input_metadata_28;

842016a2 <Lc_vol_ctrl_handle_input_metadata_27>:
            {
                op_extra_data->last_tag_data_remaining = tmp_tag->length - afteridx;
842016a2:	e3 04       	r1 = r2 - r1;
842016a4:	b3 af       	M[r4 + 88] = r1;
842016a6:	02 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_29;

842016a8 <Lc_vol_ctrl_handle_input_metadata_28>:
            }
            else
            {
                op_extra_data->last_tag_data_remaining = 0;
842016a8:	b0 af       	M[r4 + 88] = Null;

842016aa <Lc_vol_ctrl_handle_input_metadata_29>:
            }

            if (eoftag != NULL)
842016aa:	0f f8 00 c2 	Null = r6 - Null;
842016ae:	13 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_35;

842016b0 <Lc_vol_ctrl_handle_input_metadata_30>:
            {
                /* We found an EOF on the aux channel on this run
                 * bring it on the output in second to last position:
                 * aux_tag is the last tag, place eof tag in front of it. */
                eoftag->next = tmp_tag;
842016b0:	82 f0 00 ee 	M[r6 + Null] = r0;
                if (prev_tag == NULL)
842016b4:	08 04       	Null = rMAC - Null;
842016b6:	03 62       	if NE jump (m) Lc_vol_ctrl_handle_input_metadata_32;

842016b8 <Lc_vol_ctrl_handle_input_metadata_31>:
                {
                    ret_mtag = eoftag;
842016b8:	47 08       	r5 = r6 + Null;
842016ba:	03 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_33;

842016bc <Lc_vol_ctrl_handle_input_metadata_32>:
                }
                else
                {
                    prev_tag->next = eoftag;
842016bc:	18 f0 00 ee 	M[rMAC + Null] = r6;

842016c0 <Lc_vol_ctrl_handle_input_metadata_33>:
                }
                L2_DBG_MSG("volume_control: aux EOF moved to output");
842016c0:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842016c4:	88 24       	Null = rMAC - 2;
842016c6:	07 68       	if LT jump (m) Lc_vol_ctrl_handle_input_metadata_35;

842016c8 <Lc_vol_ctrl_handle_input_metadata_34>:
842016c8:	55 f1 02 f0 	r0 = Null + 357564555;
842016cc:	8b 40 
842016ce:	ef fd fa ff 	call (m) 0xccc;
842016d2:	3f ef 

842016d4 <Lc_vol_ctrl_handle_input_metadata_35>:
            }
        }
        /* write metadata to output */
        buff_metadata_append(op_extra_data->metadata_op_buffer, ret_mtag, b4idx, afteridx);
842016d4:	3d d8       	r3 = M[FP + 28];
842016d6:	34 d8       	r2 = M[FP + 24];
842016d8:	f2 a8       	r0 = M[r4 + 76];
842016da:	3b 00       	r1 = r5 + Null;
842016dc:	ff fd 98 f0 	call (m) 0x147b8;
842016e0:	3d e6 
842016e2:	05 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_37;

842016e4 <Lc_vol_ctrl_handle_input_metadata_36>:
    }
    else
    {
        /* we cannot output metadata, delete input metadata */
        buff_metadata_tag_list_delete(ret_mtag);
842016e4:	3a 00       	r0 = r5 + Null;
842016e6:	ff fd 97 f0 	call (m) 0x145ee;
842016ea:	29 e8 

842016ec <Lc_vol_ctrl_handle_input_metadata_37>:
    }
}
842016ec:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
842016ee:	d8 4c       	rts;

842016f0 <Lc_vol_ctrl_update_current_timestamp_1>:
 *        playback of aux inputs.
 * \param op_extra_data volume control operator specific data
 * \param amount_consumed amount of input consumed since last update
 */
static void vol_ctrl_update_current_timestamp(VOL_CTRL_DATA_T *op_extra_data)
{
842016f0:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
842016f2:	10 09       	r6 = r0 + Null;
    unsigned amount_consumed = op_extra_data->prev_consumed_samples;
842016f4:	87 f0 cf 88 	r5 = M[r6 + 828];
    /* This will be set again when op consumes samples from input */
    op_extra_data->prev_consumed_samples = 0;
842016f8:	80 f0 cf 8e 	M[r6 + 828] = Null;
#endif

    /* 1. See if we see timestamp in input buffer, if we do then that will
     *    be used for timed mixing of aux input.
     */
    unsigned b4idx = 0;
842016fc:	30 de       	M[FP + 24] = Null;
    metadata_tag *mtag = buff_metadata_peek_ex(op_extra_data->metadata_ip_buffer, &b4idx);
842016fe:	83 11       	r1 = FP + 24;
84201700:	82 f0 12 88 	r0 = M[r6 + 72];
84201704:	ff fd 99 f0 	call (m) 0x14930;
84201708:	2d e1 
8420170a:	16 00       	r4 = r0 + Null;
8420170c:	06 6e       	jump (m) Lc_vol_ctrl_update_current_timestamp_3;

8420170e <Lc_vol_ctrl_update_current_timestamp_2>:

            /* Op isn't generating ttp itself */
            op_extra_data->aux0_ttp.generate_ttp = FALSE;
            return;
        }
        b4idx += mtag->length;
8420170e:	f1 88       	rMAC = M[r4 + 12];
84201710:	32 d8       	r0 = M[FP + 24];
84201712:	51 00       	rMAC = r0 + rMAC;
84201714:	31 de       	M[FP + 24] = rMAC;
        mtag = mtag->next;
84201716:	36 e8       	r4 = M[r4 + Null];

84201718 <Lc_vol_ctrl_update_current_timestamp_3>:
    /* 1. See if we see timestamp in input buffer, if we do then that will
     *    be used for timed mixing of aux input.
     */
    unsigned b4idx = 0;
    metadata_tag *mtag = buff_metadata_peek_ex(op_extra_data->metadata_ip_buffer, &b4idx);
    while(mtag != NULL)
84201718:	30 04       	Null = r4 - Null;
8420171a:	36 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_10;

8420171c <Lc_vol_ctrl_update_current_timestamp_4>:
    {
        /* Search the input buffer metadata, if we see a TTP tag, then we use input time
         * stamps for the purpose of mixing time of auxiliary inputs to main inputs.
         */
        if(IS_TIMESTAMPED_TAG(mtag))
8420171c:	71 88       	rMAC = M[r4 + 4];
8420171e:	12 f0 30 00 	r0 = rMAC AND 0x30;
84201722:	f6 61       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_2;

84201724 <Lc_vol_ctrl_update_current_timestamp_5>:
84201724:	c9 c2       	rMAC = rMAC AND 0x40;
84201726:	f4 63       	if NE jump (m) Lc_vol_ctrl_update_current_timestamp_2;

84201728 <Lc_vol_ctrl_update_current_timestamp_6>:
        {
            unsigned *err_offset_id;
            unsigned out_length;
            /* go back to first input sample */
            TIME_INTERVAL time_back = convert_samples_to_time(b4idx / OCTETS_PER_SAMPLE,
                                                              op_extra_data->sample_rate);
84201728:	83 f0 3b 88 	r1 = M[r6 + 236];
8420172c:	32 d8       	r0 = M[FP + 24];
8420172e:	52 50       	r0 = r0 LSHIFT -2;
84201730:	ff fd b6 f0 	call (m) 0x183fe;
84201734:	2f e6 
            op_extra_data->current_timestamp = time_sub(mtag->timestamp, time_back);
84201736:	31 89       	rMAC = M[r4 + 16];
84201738:	89 04       	rMAC = rMAC - r0;
8420173a:	81 f0 cc 8e 	M[r6 + 816] = rMAC;
            if (buff_metadata_find_private_data(mtag, META_PRIV_KEY_TTP_OFFSET, &out_length,
                                                (void **)&err_offset_id))
8420173e:	c5 11       	r3 = FP + 28;
84201740:	04 12       	r2 = FP + 32;
84201742:	43 20       	r1 = Null + 1;
84201744:	32 00       	r0 = r4 + Null;
84201746:	ff fd 98 f0 	call (m) 0x14762;
8420174a:	3d e0 
8420174c:	10 04       	Null = r0 - Null;
8420174e:	0e 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_9;

84201750 <Lc_vol_ctrl_update_current_timestamp_7>:
            {
                int *err_offset_ptr = ttp_info_get(*err_offset_id);
84201750:	39 d8       	rMAC = M[FP + 28];
84201752:	0a e8       	r0 = M[rMAC + Null];
84201754:	ff fd c2 f0 	call (m) 0x19c1a;
84201758:	27 e6 
                if (err_offset_ptr != NULL)
8420175a:	10 04       	Null = r0 - Null;
8420175c:	07 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_9;

8420175e <Lc_vol_ctrl_update_current_timestamp_8>:
                {
                    /* subtract the offset */
                    op_extra_data->current_timestamp =
                        time_sub(op_extra_data->current_timestamp, *err_offset_ptr);
8420175e:	81 f0 cc 88 	rMAC = M[r6 + 816];
84201762:	12 e8       	r0 = M[r0 + Null];
84201764:	89 04       	rMAC = rMAC - r0;
84201766:	81 f0 cc 8e 	M[r6 + 816] = rMAC;

8420176a <Lc_vol_ctrl_update_current_timestamp_9>:
            /* current_timestamp: time stamp associated with first sample of input
             * main_timestamp_valid: whether main input has valid timestamp
             * last_main_real_timestamp: last valid timestamp we received from main input
             */
            op_extra_data->last_main_real_timestamp =
                op_extra_data->current_timestamp;
8420176a:	81 f0 cc 88 	rMAC = M[r6 + 816];
8420176e:	81 f0 cb 8e 	M[r6 + 812] = rMAC;
            op_extra_data->main_timestamp_valid = TRUE;
84201772:	41 20       	rMAC = Null + 1;
84201774:	81 f0 ca 8e 	M[r6 + 808] = rMAC;
            op_extra_data->current_timestamp_valid = TRUE;
84201778:	81 f0 cd 8e 	M[r6 + 820] = rMAC;

            /* real timestamp from input update, no accumulated remainder*/
            op_extra_data->current_timestamp_update_remainder = 0;
8420177c:	80 f0 ce 8e 	M[r6 + 824] = Null;

            /* Op isn't generating ttp itself */
            op_extra_data->aux0_ttp.generate_ttp = FALSE;
84201780:	80 f0 c8 8e 	M[r6 + 800] = Null;
84201784:	5d 6e       	jump (m) Lc_vol_ctrl_update_current_timestamp_24;

84201786 <Lc_vol_ctrl_update_current_timestamp_10>:
     *    we can build based on last received timestamp from main
     *    buffer. We stop relying on main timestamp if we
     *    haven't received any timestamp from input in last
     *    MAX_REBUILD_TIMESTAMP_PERIOD milliseconds.
     */
    if(op_extra_data->main_timestamp_valid)
84201786:	80 f0 ca 88 	Null = M[r6 + 808];
8420178a:	13 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_14;

8420178c <Lc_vol_ctrl_update_current_timestamp_11>:
    {
        TIME_INTERVAL time_passed_since_last_real_timestamp =
            time_sub(op_extra_data->current_timestamp,
                     op_extra_data->last_main_real_timestamp);
8420178c:	81 f0 cc 88 	rMAC = M[r6 + 816];
84201790:	82 f0 cb 88 	r0 = M[r6 + 812];
84201794:	89 04       	rMAC = rMAC - r0;
        if(time_passed_since_last_real_timestamp >
           (int)(VOL_CTRL_AUX_USE_MAIN_TIMESTAMP_PERIOD_MS*MILLISECOND))
84201796:	0c f0 10 f0 	Null = rMAC - 200000;
8420179a:	40 3d 
8420179c:	07 6c       	if LE jump (m) Lc_vol_ctrl_update_current_timestamp_13;

8420179e <Lc_vol_ctrl_update_current_timestamp_12>:
        {
            /* stop using main timestamp */
            op_extra_data->main_timestamp_valid = FALSE;
8420179e:	80 f0 ca 8e 	M[r6 + 808] = Null;
            op_extra_data->current_timestamp_valid = FALSE;
842017a2:	80 f0 cd 8e 	M[r6 + 820] = Null;
            op_extra_data->current_timestamp_update_remainder = 0;
842017a6:	80 f0 ce 8e 	M[r6 + 824] = Null;

842017aa <Lc_vol_ctrl_update_current_timestamp_13>:
     * to process actual aux data.
     */
    if(!op_extra_data->main_timestamp_valid &&
       op_extra_data->aux0_ttp.enabled &&
       !op_extra_data->aux0_ttp.generate_ttp &&
       !op_extra_data->aux_active)
842017aa:	80 f0 ca 88 	Null = M[r6 + 808];
842017ae:	1b 62       	if NE jump (m) Lc_vol_ctrl_update_current_timestamp_19;

842017b0 <Lc_vol_ctrl_update_current_timestamp_14>:
842017b0:	80 f0 c4 88 	Null = M[r6 + 784];
842017b4:	15 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_18;

842017b6 <Lc_vol_ctrl_update_current_timestamp_15>:
842017b6:	80 f0 c8 88 	Null = M[r6 + 800];
842017ba:	15 62       	if NE jump (m) Lc_vol_ctrl_update_current_timestamp_19;

842017bc <Lc_vol_ctrl_update_current_timestamp_16>:
842017bc:	80 f0 b8 88 	Null = M[r6 + 736];
842017c0:	0f 62       	if NE jump (m) Lc_vol_ctrl_update_current_timestamp_18;

842017c2 <Lc_vol_ctrl_update_current_timestamp_17>:
    {
        /* Start self ttp generating, with an estimated
         * target latency from current time.
         */
        TIME cur_time = time_get_time();
842017c2:	ff fd 24 f0 	call (m) 0x6100;
842017c6:	3f e9 
        op_extra_data->current_timestamp_valid = TRUE;
842017c8:	41 20       	rMAC = Null + 1;
842017ca:	81 f0 cd 8e 	M[r6 + 820] = rMAC;
        op_extra_data->current_timestamp =
            time_add(cur_time, op_extra_data->downstream_latency_estimate);
842017ce:	83 f0 d0 88 	r1 = M[r6 + 832];
842017d2:	9a 00       	r0 = r1 + r0;
842017d4:	82 f0 cc 8e 	M[r6 + 816] = r0;
        op_extra_data->aux0_ttp.generate_ttp = TRUE;
842017d8:	81 f0 c8 8e 	M[r6 + 800] = rMAC;
842017dc:	31 6e       	jump (m) Lc_vol_ctrl_update_current_timestamp_24;

842017de <Lc_vol_ctrl_update_current_timestamp_18>:
     * if input has valid timestamp op will not
     * generate ttp itself.
     * */
    op_extra_data->current_timestamp_valid =
        op_extra_data->main_timestamp_valid ||
        op_extra_data->aux0_ttp.generate_ttp;
842017de:	80 f0 ca 88 	Null = M[r6 + 808];
842017e2:	03 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_20;

842017e4 <Lc_vol_ctrl_update_current_timestamp_19>:
842017e4:	41 20       	rMAC = Null + 1;
842017e6:	06 6e       	jump (m) Lc_vol_ctrl_update_current_timestamp_21;

842017e8 <Lc_vol_ctrl_update_current_timestamp_20>:
842017e8:	41 20       	rMAC = Null + 1;
842017ea:	80 f0 c8 88 	Null = M[r6 + 800];
842017ee:	00 f0 01 c0 	if EQ rMAC = Null + Null;

842017f2 <Lc_vol_ctrl_update_current_timestamp_21>:

    /* Build timestamp from previous one considering number of samples
     * consumed since
     */
    if(op_extra_data->current_timestamp_valid && amount_consumed != 0)
842017f2:	81 f0 cd 8e 	M[r6 + 820] = rMAC;
842017f6:	24 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_24;

842017f8 <Lc_vol_ctrl_update_current_timestamp_22>:
842017f8:	38 04       	Null = r5 - Null;
842017fa:	22 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_24;

842017fc <Lc_vol_ctrl_update_current_timestamp_23>:
    {
        /* new_time_stamp = previous_time_stamp + amount_consumed/sample_rate
         * we keep a remainder to avoid the effect of truncation.
         */
        uint64 tm_mul = (uint64)amount_consumed * 1000000 +
            op_extra_data->current_timestamp_update_remainder;
842017fc:	82 f0 ce 88 	r0 = M[r6 + 824];
84201800:	00 f0 42 ff 	rMAC = r5 * 0.00023283064365386962890625 (UU);
84201804:	40 f7 11 cc 
84201808:	09 50       	rMAC = rMAC LSHIFT -1 (56bit);
8420180a:	00 f1 d5 c8 	r3 = rMAC LSHIFT 0;
8420180e:	cc 57       	r2 = rMAC LSHIFT 32;
84201810:	16 01       	r4 = r0 + r2;
84201812:	47 03       	r5 = Null + r3 + Carry;
        TIME_INTERVAL time_passed = (TIME_INTERVAL) (tm_mul/op_extra_data->sample_rate);
84201814:	89 f0 3b 88 	r7 = M[r6 + 236];
84201818:	4c 08       	r2 = r7 + Null;
8420181a:	05 00       	r3 = Null + Null;
8420181c:	3b 00       	r1 = r5 + Null;
8420181e:	32 00       	r0 = r4 + Null;
84201820:	ff fd c4 f0 	call (m) 0x1a208;
84201824:	29 ef 
84201826:	11 00       	rMAC = r0 + Null;
        op_extra_data->current_timestamp_update_remainder =
            (unsigned)(tm_mul - ((uint64)time_passed*op_extra_data->sample_rate));
84201828:	32 00       	r0 = r4 + Null;
8420182a:	9f f1 83 c9 	r1 = rMAC * r7 (int);
8420182e:	d2 04       	r0 = r0 - r1;
84201830:	82 f0 ce 8e 	M[r6 + 824] = r0;
        op_extra_data->current_timestamp =
            time_add(op_extra_data->current_timestamp, time_passed);
84201834:	82 f0 cc 88 	r0 = M[r6 + 816];
84201838:	51 00       	rMAC = r0 + rMAC;
8420183a:	81 f0 cc 8e 	M[r6 + 816] = rMAC;

8420183e <Lc_vol_ctrl_update_current_timestamp_24>:
    }
}
8420183e:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
84201840:	d8 4c       	rts;

84201842 <Lc_vol_ctrl_timestamp_void_tags_1>:
 * \octets_before_tag octets before mtag first octet
 */
static void vol_ctrl_timestamp_void_tags(VOL_CTRL_DATA_T *op_extra_data,
                                         metadata_tag *mtag,
                                         unsigned octets_before_tag)
{
84201842:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201844:	16 00       	r4 = r0 + Null;
84201846:	1f 00       	r5 = r1 + Null;
84201848:	20 09       	r6 = r2 + Null;

8420184a <Lc_vol_ctrl_timestamp_void_tags_2>:
    while(NULL != mtag)
8420184a:	38 04       	Null = r5 - Null;
8420184c:	1d 60       	if EQ jump (m) Lc_vol_ctrl_timestamp_void_tags_7;

8420184e <Lc_vol_ctrl_timestamp_void_tags_3>:
    {
        /* traverse through all tags in the list*/
        if(IS_VOID_TTP_TAG(mtag))
8420184e:	79 88       	rMAC = M[r5 + 4];
84201850:	11 f0 70 00 	rMAC = rMAC AND 0x70;
84201854:	10 f0 50 24 	Null = rMAC - 80;
84201858:	13 62       	if NE jump (m) Lc_vol_ctrl_timestamp_void_tags_6;

8420185a <Lc_vol_ctrl_timestamp_void_tags_4>:
8420185a:	38 89       	Null = M[r5 + 16];
8420185c:	11 62       	if NE jump (m) Lc_vol_ctrl_timestamp_void_tags_6;

8420185e <Lc_vol_ctrl_timestamp_void_tags_5>:
            /* tags is a VOID tag, turn it to a TIMESTAMP tags.
             * Note: current_timestamp field holds ttp for octet 0
             */
            TIME_INTERVAL time_passed =
                convert_samples_to_time(octets_before_tag/ADDR_PER_WORD,
                                        op_extra_data->sample_rate);
8420185e:	63 f0 3b 88 	r1 = M[r4 + 236];
84201862:	7f f8 d2 c8 	r0 = r6 LSHIFT -2;
84201866:	ff fd b5 f0 	call (m) 0x183fe;
8420186a:	39 ec 
            METADATA_TIME_OF_ARRIVAL_UNSET(mtag);
8420186c:	79 88       	rMAC = M[r5 + 4];
8420186e:	11 ff bf 1f 	rMAC = rMAC AND 0xffffffbf;
            METADATA_TIMESTAMP_SET(mtag,
                                   time_add(op_extra_data->current_timestamp, time_passed),
                                   METADATA_TIMESTAMP_LOCAL);
84201872:	c9 c9       	rMAC = rMAC OR 0x10;
84201874:	79 8e       	M[r5 + 4] = rMAC;
84201876:	61 f0 cc 88 	rMAC = M[r4 + 816];
8420187a:	51 00       	rMAC = r0 + rMAC;
8420187c:	39 8f       	M[r5 + 16] = rMAC;

8420187e <Lc_vol_ctrl_timestamp_void_tags_6>:
        }
        octets_before_tag += mtag->length;
8420187e:	f9 88       	rMAC = M[r5 + 12];
84201880:	08 0d       	r6 = rMAC + r6;
        mtag = mtag->next;
84201882:	3f e8       	r5 = M[r5 + Null];
 */
static void vol_ctrl_timestamp_void_tags(VOL_CTRL_DATA_T *op_extra_data,
                                         metadata_tag *mtag,
                                         unsigned octets_before_tag)
{
    while(NULL != mtag)
84201884:	e3 6f       	jump (m) Lc_vol_ctrl_timestamp_void_tags_2;

84201886 <Lc_vol_ctrl_timestamp_void_tags_7>:
                                   METADATA_TIMESTAMP_LOCAL);
        }
        octets_before_tag += mtag->length;
        mtag = mtag->next;
    }
}
84201886:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201888:	d8 4c       	rts;

8420188a <Lc_vol_ctrl_setup_mute_1>:
    op_extra_data->channels = NULL;
}


static void vol_ctrl_setup_mute(VOL_CTRL_DATA_T *op_extra_data,unsigned bMute)
{
8420188a:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
8420188c:	16 00       	r4 = r0 + Null;
8420188e:	1f 00       	r5 = r1 + Null;

    /*  cur_mute_gain = 0 at start, and default mute=FALSE
        To immediately unmute set mute_period=0
    */

    if((op_extra_data->sample_rate<1) || (op_extra_data->mute_period<1) )
84201890:	63 f0 3b 88 	r1 = M[r4 + 236];
84201894:	04 60       	if EQ jump (m) Lc_vol_ctrl_setup_mute_3;

84201896 <Lc_vol_ctrl_setup_mute_2>:
84201896:	62 f0 c0 88 	r0 = M[r4 + 768];
8420189a:	0b 62       	if NE jump (m) Lc_vol_ctrl_setup_mute_4;

8420189c <Lc_vol_ctrl_setup_mute_3>:
    {
        /* Immediately set mute gain */
        op_extra_data->cur_mute_gain  = bMute ? 0 : FRACTIONAL(1.0);
8420189c:	ff f7 f1 f7 	rMAC = Null + 2147483647;
842018a0:	ff 7b 
842018a2:	38 04       	Null = r5 - Null;
842018a4:	01 f0 01 c0 	if NE rMAC = Null + Null;
842018a8:	61 f0 c1 8e 	M[r4 + 772] = rMAC;
        mute_increment=1;
842018ac:	42 20       	r0 = Null + 1;
842018ae:	17 6e       	jump (m) Lc_vol_ctrl_setup_mute_7;

842018b0 <Lc_vol_ctrl_setup_mute_4>:
    }
    else
    {

        if(op_extra_data->mute_period<1000)
842018b0:	20 f0 e8 27 	Null = r0 - 1000;
842018b4:	02 f0 a1 e0 	if C jump (m) Lc_vol_ctrl_setup_mute_6;

842018b8 <Lc_vol_ctrl_setup_mute_5>:
        {
            mute_increment = pl_fractional_divide(op_extra_data->mute_period,1000);
842018b8:	03 f0 e8 43 	r1 = Null + 1000;
842018bc:	ff fd e0 f1 	call (m) 0x3d950;
842018c0:	35 e4 
            mute_increment = pl_fractional_divide(1,frac_mult(mute_increment,op_extra_data->sample_rate));
842018c2:	63 f0 3b 88 	r1 = M[r4 + 236];
842018c6:	3f f2 43 c9 	r1 = r0 * r1 (frac);
842018ca:	42 20       	r0 = Null + 1;
842018cc:	ff fd e0 f1 	call (m) 0x3d950;
842018d0:	25 e4 
842018d2:	05 6e       	jump (m) Lc_vol_ctrl_setup_mute_7;

842018d4 <Lc_vol_ctrl_setup_mute_6>:
        }
        else
        {
            mute_increment = pl_fractional_divide(1,op_extra_data->sample_rate);
842018d4:	42 20       	r0 = Null + 1;
842018d6:	ff fd e0 f1 	call (m) 0x3d950;
842018da:	3b e3 

842018dc <Lc_vol_ctrl_setup_mute_7>:
        }
    }

    /* Set direction of transition */
    op_extra_data->mute_increment = (bMute) ? -mute_increment : mute_increment;
842018dc:	38 04       	Null = r5 - Null;
842018de:	05 60       	if EQ jump (m) Lc_vol_ctrl_setup_mute_9;

842018e0 <Lc_vol_ctrl_setup_mute_8>:
842018e0:	81 04       	rMAC = Null - r0;
842018e2:	61 f0 c2 8e 	M[r4 + 776] = rMAC;
842018e6:	03 6e       	jump (m) Lc_vol_ctrl_setup_mute_10;

842018e8 <Lc_vol_ctrl_setup_mute_9>:
842018e8:	62 f0 c2 8e 	M[r4 + 776] = r0;

842018ec <Lc_vol_ctrl_setup_mute_10>:

}
842018ec:	f2 48       	popm <FP, r4, r5, rLink>;
842018ee:	d8 4c       	rts;

842018f0 <Lc_pack_aux_state_1>:
}
#endif /* INSTALL_METADATA */

#ifdef VOLUME_CONTROL_AUX_TIMING_TRACE
static uint32 pack_aux_state(VOL_CTRL_DATA_T *op_extra_data)
{
842018f0:	48 1d       	pushm <FP(=SP)>, SP = SP + 0x10;
    VOL_CTRL_PACKED_AUX_STATE packed_aux_state;

    packed_aux_state.u.f.aux_state = op_extra_data->aux_channel[0].state;
842018f2:	21 f0 70 80 	rMAC = MBS[r0 + 112];
842018f6:	10 de       	M[FP + 8] = Null;
842018f8:	41 da       	MB[FP + 8] = rMAC;
    packed_aux_state.u.f.aux_pending = op_extra_data->aux_pending;
842018fa:	21 f0 bc 88 	rMAC = M[r0 + 752];
842018fe:	49 da       	MB[FP + 9] = rMAC;
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
    packed_aux_state.u.f.ttp_enabled = op_extra_data->aux0_ttp.enabled;
84201900:	21 f0 c4 88 	rMAC = M[r0 + 784];
84201904:	51 da       	MB[FP + 10] = rMAC;
    packed_aux_state.u.f.generate_ttp = op_extra_data->aux0_ttp.generate_ttp;
84201906:	21 f0 c8 88 	rMAC = M[r0 + 800];
8420190a:	59 da       	MB[FP + 11] = rMAC;
#endif

    return packed_aux_state.u.w;
8420190c:	12 d8       	r0 = M[FP + 8];

8420190e <Lc_pack_aux_state_2>:
}
8420190e:	48 49       	SP = SP - 0x10, popm <FP>;
84201910:	d8 4c       	rts;

84201912 <Lc_record_aux_ttr_event_1>:

static void record_aux_ttr_event(OPERATOR_DATA *op_data,
                                 TIMING_TRACE_OP_EVENT_TYPE event_type,
                                 unsigned arg1,
                                 unsigned arg2)
{
84201912:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201914:	1e 00       	r4 = r1 + Null;
84201916:	27 00       	r5 = r2 + Null;
84201918:	28 09       	r6 = r3 + Null;
    /* Always use the ID for sink terminal 1 */
    ENDPOINT_ID aux_in_ep_id = base_op_get_ext_op_id(op_data) |
            STREAM_EP_EXT_SINK | VOL_CTRL_TTR_EVENT_TERMINAL_NUM;
8420191a:	ef fd f5 ff 	call (m) 0x4f4;
8420191e:	3b ee 
84201920:	a0 f0 01 f2 	r0 = r0 OR 0xa001;
84201924:	52 d8 
    opmgr_record_timing_trace_op_term_event(aux_in_ep_id, event_type, arg1, arg2);
84201926:	45 08       	r3 = r6 + Null;
84201928:	3c 00       	r2 = r5 + Null;
8420192a:	33 00       	r1 = r4 + Null;
8420192c:	01 f0 21 e2 	call (m) $_opmgr_record_timing_trace_op_term_event;

84201930 <Lc_record_aux_ttr_event_2>:
}
84201930:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201932:	d8 4c       	rts;

84201934 <Lc_ups_params_vc_1>:



static bool ups_params_vc(void* instance_data,PS_KEY_TYPE key,PERSISTENCE_RANK rank,
                          uint16 length, unsigned* data, STATUS_KYMERA status,uint16 extra_status_info)
{
84201934:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84201936:	2f 00       	r5 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201938:	ef fd f5 ff 	call (m) 0x4e6;
8420193c:	2f ed 
8420193e:	16 00       	r4 = r0 + Null;
static bool ups_params_vc(void* instance_data,PS_KEY_TYPE key,PERSISTENCE_RANK rank,
                          uint16 length, unsigned* data, STATUS_KYMERA status,uint16 extra_status_info)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data((OPERATOR_DATA*)instance_data);

    cpsSetParameterFromPsStore(&op_extra_data->parms_def,length,data,status);
84201940:	e5 d5       	r3 = MHS[FP + -8];
84201942:	fc d9       	r2 = M[FP + -4];
84201944:	62 f0 b4 22 	r0 = r4 + 692;
84201948:	3b 00       	r1 = r5 + Null;
8420194a:	ef fd f8 ff 	call (m) 0xa0a;
8420194e:	21 e6 

    /* Set the Reinit flag after setting the parameters */
    op_extra_data->ReInitFlag = 1;
84201950:	41 20       	rMAC = Null + 1;
84201952:	61 f0 ac 8e 	M[r4 + 688] = rMAC;

    return TRUE;
84201956:	0a 00       	r0 = rMAC + Null;

84201958 <Lc_ups_params_vc_2>:
}
84201958:	f2 48       	popm <FP, r4, r5, rLink>;
8420195a:	d8 4c       	rts;

8420195c <$_VOL_CTRL_GetDefaults>:
   0x7999999Au,			// LIMIT_ADAPTATION_RATIO
   0xFFD57A44u			// LIMIT_THRESHOLD_LOG
};

unsigned *VOL_CTRL_GetDefaults(unsigned capid){
	switch(capid){
8420195c:	20 f0 48 24 	Null = r0 - 72;
84201960:	05 60       	if EQ jump (m) Lc_VOL_CTRL_GetDefaults_3;

84201962 <Lc_VOL_CTRL_GetDefaults_2>:
84201962:	01 f0 20 f0 	Null = r0 - 16468;
84201966:	54 24 
84201968:	05 62       	if NE jump (m) Lc_VOL_CTRL_GetDefaults_4;

8420196a <Lc_VOL_CTRL_GetDefaults_3>:
		case 0x0048: return defaults_vol_ctrlVOL_V2PLUS;
8420196a:	f8 ff 02 f0 	r0 = Null + -8388604;
8420196e:	04 40 
84201970:	02 6e       	jump (m) Lc_VOL_CTRL_GetDefaults_5;

84201972 <Lc_VOL_CTRL_GetDefaults_4>:
		case 0x4054: return defaults_vol_ctrlVOL_V2PLUS;
	}
	return((unsigned *)0);
84201972:	02 00       	r0 = Null + Null;

84201974 <Lc_VOL_CTRL_GetDefaults_5>:
84201974:	d8 4c       	rts;

84201976 <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_vol_ctlr_cap_data;
84201976:	07 f0 02 f0 	r0 = Null + 7340192;
8420197a:	a0 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
8420197c:	20 f0 f8 42 	Null = Null + 17144;

84201980 <$_vol_ctrl_update_aux_state>:
.CONST $vol_ctrl.axfp.period        4*ADDR_PER_WORD;  // r3
.MODULE $M.vol_ctrl_update_aux_state;
    .CODESEGMENT PM;

$_vol_ctrl_update_aux_state:
    pushm <r5,r7>;
84201980:	28 f0 40 e0 	pushm <r5, r7>;

    LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($vol_ctrl_update_aux_state.PATCH_ID_0, r7)

    // Check if any AUX to monitor
    r7 = r1;
84201984:	19 09       	r7 = r1 + Null;
    if Z jump update_aux_state_abort;
84201986:	b7 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_abort;

    r5 = r0;
84201988:	17 00       	r5 = r0 + Null;

    /* Setup Parameters Pointer */
    r1 = r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD +
               $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_AUX1_SCALE_FIELD);
8420198a:	23 f0 94 21 	r1 = r0 + 404;
    /* Setup Aux Pointer */
    r0 = r5 + $volume_control_cap._vol_ctrl_data_struct.AUX_CHANNEL_FIELD;
8420198e:	72 f0 6c 20 	r0 = r5 + 108;
    /* setup period */
    r3 = M[r2 + $volume_control_cap.vol_time_constants_struct.PERIOD_FIELD];
84201992:	25 89       	r3 = M[r2 + 16];
    /* Get number of words to process */
    r2 = M[r2 + $volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD];
84201994:	24 88       	r2 = M[r2 + 0];

    pushm <FP(=SP),r0,r1,r2,r3,r4,r6,r8,rLink>;
84201996:	57 f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r3, r4, r6, r8, rLink>;

    r8 = NULL;
8420199a:	02 09       	r8 = Null + Null;
    r6 = 1;
8420199c:	08 71       	r6 = Null + 1;

8420199e <$M.vol_ctrl_update_aux_state.vol_ctrl_update_aux_state_next>:

    // r0: vol_ctrl_aux_channel_t *aux
    // r1: vol_ctrl_aux_params_t *aux_params

    // Get aux->state
    r4 = M[r0 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD];
8420199e:	56 88       	r4 = M[r0 + 4];
    // In aux timed playback mode we don't allow aux data
    // to be consumed until the right time.

    // Auxiliary timed playback is only for channel 0, skip ttp handling
    // if this isn't first aux channel.
    r1 = r5 + $volume_control_cap._vol_ctrl_data_struct.AUX_CHANNEL_FIELD;
842019a0:	73 f0 6c 20 	r1 = r5 + 108;
    NULL = r1 - r0;
842019a4:	98 04       	Null = r1 - r0;
    if NZ jump aux_ttp_gate_control_done;
842019a6:	22 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;
    // timed playback requires that aux ttp to have been enabled by the user and
    // also we have valid timestamp to honour the ttp request, check both below,
    // if any fails then no gate control.

    // see if TTP is enabled for this aux channel
    NULL = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)];
842019a8:	70 f0 c4 88 	Null = M[r5 + 784];
    if Z jump aux_ttp_gate_control_done;
842019ac:	1f 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;
    // also see if we have a valid timestamp to handle aux timed playback
    // if not as if aux ttp isn't enabled
    NULL = M[r5 + $volume_control_cap._vol_ctrl_data_struct.CURRENT_TIMESTAMP_VALID_FIELD];
842019ae:	70 f0 cd 88 	Null = M[r5 + 820];
    if Z jump aux_ttp_gate_control_done;
842019b2:	1c 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;
    // time to open the gate. We open the gate when time passes TTP_GATE_TIME,
    // this is a bit before AUX_TTP time (default 10ms but user configurable) it will
    // give time to main channel for fading.
    // r1 = time stamp for first sample
    // r3 = ttp gate time
    r1 = M[r5 + $volume_control_cap._vol_ctrl_data_struct.CURRENT_TIMESTAMP_FIELD];
842019b4:	73 f0 cc 88 	r1 = M[r5 + 816];
    r3 = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(GATE_TIME)];
842019b8:	75 f0 c7 88 	r3 = M[r5 + 796];
    r3 = r1 - r3;
842019bc:	5d 05       	r3 = r1 - r3;
    if POS jump check_aux_ttp_expiry;
842019be:	05 f0 97 e0 	if POS jump (m) $M.vol_ctrl_update_aux_state.check_aux_ttp_expiry;

    // gate time hasn't passed yet, AUX is expected to be
    // inactive, if for any reason it is in an active state
    // then we can't meet TTP deadline, just disable TTP playback.
    NULL = r4 - $volume_control_cap.AUX_STATE_NO_AUX;
842019c2:	30 24       	Null = r4 - 0;
    if NZ jump disable_aux_ttp;
842019c4:	0f 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.disable_aux_ttp;
    // see if it is the time to open the gate
    // we open the gate if the gate time lies in
    // a sample within this chunk, i.e between
    // current timestamp and and next timestamp
    // timestamp ----gate_time --- (timestamp+period)
    rMAC = M[FP + $vol_ctrl.axfp.period]; // rMAC = period in 10us
842019c6:	21 d8       	rMAC = M[FP + 16];
    rMAC = rMAC * 10 (int);               // rMAC = period in us
842019c8:	89 42       	rMAC = rMAC * 10 (int);
    NULL = r3 + rMAC;                     // rMAC > time left to gate?
842019ca:	68 00       	Null = r3 + rMAC;
    if POS jump aux_ttp_gate_control_done;// if yes then open the gate
842019cc:	05 f0 9f e0 	if POS jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;
    // keep the gate closed
    // it's not time to open the aux gate
    // don't allow anything to be consumed from aux
    M[r0 + $volume_control_cap.vol_ctrl_aux_channel_struct.ADVANCE_BUFFER_FIELD] = 0;
842019d0:	d0 8e       	M[r0 + 12] = Null;
    jump aux_ttp_gate_control_done;
842019d2:	0c 6e       	jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;

842019d4 <$M.vol_ctrl_update_aux_state.check_aux_ttp_expiry>:

check_aux_ttp_expiry:
    // if expiry time has reached and we haven't yet started
    // playing the aux then no longer need to honour the timed
    // playback request, we can't meet the deadline.
    NULL = r4 - $volume_control_cap.AUX_STATE_NO_AUX;
842019d4:	30 24       	Null = r4 - 0;
    if NZ jump aux_ttp_gate_control_done;
842019d6:	0a 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;

    r3 = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(EXPIRY_TIME)];
842019d8:	75 f0 c6 88 	r3 = M[r5 + 792];
    NULL = r1 - r3;
842019dc:	58 05       	Null = r1 - r3;
    if NEG jump aux_ttp_gate_control_done;
842019de:	04 f0 8d e0 	if NEG jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;

842019e2 <$M.vol_ctrl_update_aux_state.disable_aux_ttp>:
    // Aux ttp has expired
disable_aux_ttp:
    // disabling aux timed playback
    M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)] = NULL;
842019e2:	70 f0 c4 8e 	M[r5 + 784] = Null;
    M[r5 + VOL_CTRL_AUX0_TTP_FIELD(GENERATE_TTP)] = 0;
842019e6:	70 f0 c8 8e 	M[r5 + 800] = Null;

842019ea <$M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done>:
aux_ttp_gate_control_done:
#endif // VOLUME_CONTROL_AUX_TTP_SUPPORT
    // amount = aux_ptr->advance_buffer
    //        = aux_ptr->buffer ? cbuffer_calc_amount_data_in_words(aux_ptr->buffer) : 0
    r0 = M[r0 + $volume_control_cap.vol_ctrl_aux_channel_struct.ADVANCE_BUFFER_FIELD];
842019ea:	d2 88       	r0 = M[r0 + 12];


    // Is Aux Data Present in sufficient quantity to mix?
    r1 = M[FP + $vol_ctrl.axfp.num_words];
842019ec:	1b d8       	r1 = M[FP + 12];
    NULL = r1 - r0;
842019ee:	98 04       	Null = r1 - r0;
    if GT jump update_aux_state_insufficient_data;
842019f0:	50 6a       	if GT jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_insufficient_data;

842019f2 <$M.vol_ctrl_update_aux_state.update_aux_state_sufficient_data>:

    update_aux_state_sufficient_data:
        r3 = M[FP + $vol_ctrl.axfp.aux_ptr];
842019f2:	0d d8       	r3 = M[FP + 4];
        // aux_ptr->advance_buffer = volume_tc.num_words;
        M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.ADVANCE_BUFFER_FIELD]=r1;
842019f4:	eb 8e       	M[r3 + 12] = r1;

        NULL = r4 - $volume_control_cap.AUX_STATE_IN_AUX;
842019f6:	b0 24       	Null = r4 - 2;
        if Z jump update_aux_state_done;
842019f8:	6c 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_done;
        /* Not in IN_AUX state */
        NULL = r4 - $volume_control_cap.AUX_STATE_START_AUX;
842019fa:	70 24       	Null = r4 - 1;
        if Z jump update_aux_state_in_AUX_START;
842019fc:	04 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_in_AUX_START;
            /* Not in START_AUX state, enter START_AUX state
               Start count down.  Don't use data until in IN_AUX state */
            r1 = $volume_control_cap.AUX_STATE_START_AUX;
842019fe:	43 20       	r1 = Null + 1;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD] = r1;
84201a00:	6b 8e       	M[r3 + 4] = r1;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = NULL;
84201a02:	a8 8e       	M[r3 + 8] = Null;

84201a04 <$M.vol_ctrl_update_aux_state.update_aux_state_in_AUX_START>:
           // jump update_aux_do_not_use_data;
        update_aux_state_in_AUX_START:
            /* Continue count down */
            r0 = M[FP + $vol_ctrl.axfp.period];
84201a04:	22 d8       	r0 = M[FP + 16];
            r1 = M[FP + $vol_ctrl.axfp.aparm_ptr];
84201a06:	13 d8       	r1 = M[FP + 8];
            r1 = M[r1 + $volume_control_cap.vol_ctrl_aux_params_struct.ATK_TC_FIELD];
84201a08:	5b 88       	r1 = M[r1 + 4];
            rMAC = r0 * r1;
84201a0a:	3f f2 c1 cc 	rMAC = r0 * r1 (SS);
            rMAC = rMAC ASHIFT (DAWTH-1) (56bit);
84201a0e:	89 5f       	rMAC = rMAC ASHIFT 31 (56bit);
            r0 = M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD];
84201a10:	aa 88       	r0 = M[r3 + 8];
            r2 = 1.0;
84201a12:	ff f7 f4 f7 	r2 = Null + 2147483647;
84201a16:	ff 7b 
            rMAC = rMAC + r0;
84201a18:	51 00       	rMAC = r0 + rMAC;
            if V rMAC = r2;
84201a1a:	06 f4 01 c0 	if V rMAC = r2 + Null;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = rMAC;
84201a1e:	a9 8e       	M[r3 + 8] = rMAC;
            NULL = rMAC - r2;
84201a20:	08 05       	Null = rMAC - r2;
            if NZ jump update_aux_do_not_use_data;
84201a22:	56 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;

#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
            /* auxiliary timed playback is only for channel 0, skip ttp handling
             * if this isn't first aux channel.
             */
            r1 = r5 + $volume_control_cap._vol_ctrl_data_struct.AUX_CHANNEL_FIELD;
84201a24:	73 f0 6c 20 	r1 = r5 + 108;
            NULL = r1 - r3;
84201a28:	58 05       	Null = r1 - r3;
            if NZ jump aux_ttp_start_done;
84201a2a:	2d 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done;
            // time we start mixing aux into main channel. In ttp mode we
            // might need to delay it to make sure aux starts mixing at a time
            // as close as to requested playback time.

            // see if TTP is enabled at all for aux channel
            NULL = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)];
84201a2c:	70 f0 c4 88 	Null = M[r5 + 784];
            if Z jump aux_ttp_start_done;
84201a30:	2a 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done;
            // and we have valid timestamp
            NULL = M[r5 + $volume_control_cap._vol_ctrl_data_struct.CURRENT_TIMESTAMP_VALID_FIELD];
84201a32:	70 f0 cd 88 	Null = M[r5 + 820];
            if Z jump aux_ttp_start_done;
84201a36:	27 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done;

            // r1 = aux requested ttp, this is the timestamp we want the aux to be mixed with main
            // r2 = timestamp, this is the timestamp for first sample of main
            r1 = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(TIME_TO_PLAY)];
84201a38:	73 f0 c5 88 	r1 = M[r5 + 788];
            r2 = M[r5 + $volume_control_cap._vol_ctrl_data_struct.CURRENT_TIMESTAMP_FIELD];
84201a3c:	74 f0 cc 88 	r2 = M[r5 + 816];
            r1 = r1 - r2;
84201a40:	1b 05       	r1 = r1 - r2;

            // because of the gate we expect to be very close to TTP time. If that
            // not the case, i.e. it's unexpectedly far in the future then something
            // should have gone wrong, to avoid stalling of mixing for long time ignore
            // TTP and let it go ahead with mixing.
            NULL = r1 - $vol_ctrl.MAX_EXTENDING_START_TRANSIENT_TIME_US;
84201a42:	01 f0 30 f3 	Null = r1 - 30000;
84201a46:	30 2d 
            if POS jump aux_ttp_start_done_without_ttp;
84201a48:	05 f0 b9 e0 	if POS jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done_without_ttp;
            // Good news, we are very close to TTP time, lets work out how
            // many sample we are to TTP time
            // samples = time * fs
            // r1 = time*1000000, so we calculate it this way:
            // samples = (r1 / 2000) * (fs/500)
            r2 = M[r5 + $volume_control_cap._vol_ctrl_data_struct.SAMPLE_RATE_FIELD];
84201a4c:	74 f0 3b 88 	r2 = M[r5 + 236];
            r2 = r2 * (1/500.0)(frac);
84201a50:	04 f0 89 f1 	r2 = r2 * 0.0019999998621642589569091796875 (frac);
84201a54:	37 f4 54 c9 
            r2 = r2 * r1 (int)(sat);
84201a58:	00 f3 f4 c9 	r2 = r2 * r1 (int) (sat);
            r2 = r2 * (1.0/2000.0)(frac); // r2 = samples to ttp time
84201a5c:	01 f0 62 f0 	r2 = r2 * 0.000500000081956386566162109375 (frac);
84201a60:	4e f4 54 c9 
            // negative r2 means that ttp was in a sample in the past
            // i.e. already exited the operator, this shall not happen
            // since we open the gate at right time, however in case that
            // happened continue without ttp.
            if NEG jump aux_ttp_start_done_without_ttp;
84201a64:	04 f0 9d e0 	if NEG jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done_without_ttp;

            // r2 = 0, means TTP is exactly at first sample,
            // lucky, go to IN_AUX state now and start mixing
            if Z jump aux_ttp_start_done;
84201a68:	0e 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done;

            // if TTP is for later than whole of this chunk then extend transient time
            rMAC = M[FP + $vol_ctrl.axfp.num_words];
84201a6a:	19 d8       	rMAC = M[FP + 12];
            NULL = r2 - rMAC;
84201a6c:	60 04       	Null = r2 - rMAC;
            if POS jump update_aux_do_not_use_data;
84201a6e:	05 f0 e1 e0 	if POS jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;

            // TTP lies somewhere within current chunk, we split the
            // current chunk, so only samples before TTP are consumed
            // from the main channel, so next time will be start of TTP
            rMAC = r5 + $volume_control_cap._vol_ctrl_data_struct.TC_FIELD;
84201a72:	71 f0 c8 22 	rMAC = r5 + 712;
            M[rMAC + $volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD] = r2;
84201a76:	0c 8e       	M[rMAC + 0] = r2;
            M[FP + $vol_ctrl.axfp.num_words] = r2;
84201a78:	1c de       	M[FP + 12] = r2;
            r1 = r1 * 10 (int);
84201a7a:	9b 42       	r1 = r1 * 10 (int);
            M[FP + $vol_ctrl.axfp.period] = r1;
84201a7c:	23 de       	M[FP + 16] = r1;
            jump update_aux_do_not_use_data;
84201a7e:	28 6e       	jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;

84201a80 <$M.vol_ctrl_update_aux_state.aux_ttp_start_done_without_ttp>:
            // We are here since either ttp time passed or is quite into the future.
            // We aren't expected to come to this point if gate opened at right time.
            // We go to IN_AUX now and timed playback won't be honoured.
            // clearing TTP_ENABLED field but not stopping TTP generation if active,
            // this is to avoid unnecessary disturbance it timed playback.
            M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)] = 0;
84201a80:	70 f0 c4 8e 	M[r5 + 784] = Null;

84201a84 <$M.vol_ctrl_update_aux_state.aux_ttp_start_done>:
aux_ttp_start_done:
            // debug var only, just shows that started to mix aux, the flag shall be
            // cleared by the caller.
            r1 = 1;
84201a84:	43 20       	r1 = Null + 1;
            M[r5 + $volume_control_cap._vol_ctrl_data_struct.DBG_AUX_MIXING_STARTED_FIELD] = r1;
84201a86:	73 f0 d1 8e 	M[r5 + 836] = r1;
#endif // VOLUME_CONTROL_AUX_TTP_SUPPORT
            /* Entering IN_AUX state */
            r1 = $volume_control_cap.AUX_STATE_IN_AUX;
84201a8a:	83 20       	r1 = Null + 2;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD] = r1;
84201a8c:	6b 8e       	M[r3 + 4] = r1;
            jump update_aux_state_done;
84201a8e:	21 6e       	jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_done;

84201a90 <$M.vol_ctrl_update_aux_state.update_aux_state_insufficient_data>:

     update_aux_state_insufficient_data:
        r3 = M[FP + $vol_ctrl.axfp.aux_ptr];
84201a90:	0d d8       	r3 = M[FP + 4];
        // aux_ptr->advance_buffer = amount;

        NULL = r4 - $volume_control_cap.AUX_STATE_NO_AUX;
84201a92:	30 24       	Null = r4 - 0;
        if Z jump update_aux_do_not_use_data;
84201a94:	1d 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;
        /* Not in NO_AUX state */
        NULL = r4 - $volume_control_cap.AUX_STATE_END_AUX;
84201a96:	f0 24       	Null = r4 - 3;
        if Z jump update_aux_state_in_AUX_END;
84201a98:	07 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_in_AUX_END;
            /* Not in END_AUX state, enter END_AUX state
               Start count down.  Don't purge data until in NO_AUX state */
            r1 = $volume_control_cap.AUX_STATE_END_AUX;
84201a9a:	c3 20       	r1 = Null + 3;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD] = r1;
84201a9c:	6b 8e       	M[r3 + 4] = r1;
            r1 = 1.0;
84201a9e:	ff f7 f3 f7 	r1 = Null + 2147483647;
84201aa2:	ff 7b 
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = r1;
84201aa4:	ab 8e       	M[r3 + 8] = r1;

84201aa6 <$M.vol_ctrl_update_aux_state.update_aux_state_in_AUX_END>:
           // jump update_aux_do_not_use_data;
       update_aux_state_in_AUX_END:
            /* Continue count down */
            r0 = M[FP + $vol_ctrl.axfp.period];
84201aa6:	22 d8       	r0 = M[FP + 16];
            r1 = M[FP + $vol_ctrl.axfp.aparm_ptr];
84201aa8:	13 d8       	r1 = M[FP + 8];
            r1 = M[r1 + $volume_control_cap.vol_ctrl_aux_params_struct.DEC_TC_FIELD];
84201aaa:	9b 88       	r1 = M[r1 + 8];
            rMAC = r0 * r1;
84201aac:	3f f2 c1 cc 	rMAC = r0 * r1 (SS);
            rMAC = rMAC ASHIFT (DAWTH-1) (56bit);
84201ab0:	89 5f       	rMAC = rMAC ASHIFT 31 (56bit);
            r2 = M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD];
84201ab2:	ac 88       	r2 = M[r3 + 8];
            rMAC = r2 - rMAC;
84201ab4:	61 04       	rMAC = r2 - rMAC;
            if NEG rMAC=NULL;
84201ab6:	04 f0 01 c0 	if NEG rMAC = Null + Null;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = rMAC;
84201aba:	a9 8e       	M[r3 + 8] = rMAC;
            if GT jump update_aux_do_not_use_data;
84201abc:	09 6a       	if GT jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
            // timed playback is only for one tone/prompt, once
            // finished disable aux timed playback
            M[r5 + VOL_CTRL_AUX0_TTP_FIELD(GENERATE_TTP)] = 0;
84201abe:	70 f0 c8 8e 	M[r5 + 800] = Null;
            M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)] = 0;
84201ac2:	70 f0 c4 8e 	M[r5 + 784] = Null;
#endif
            /* Entering NO_AUX state */
            r1 = $volume_control_cap.AUX_STATE_NO_AUX;
84201ac6:	03 00       	r1 = Null + Null;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD] = r1;
84201ac8:	6b 8e       	M[r3 + 4] = r1;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = NULL;
84201aca:	a8 8e       	M[r3 + 8] = Null;
            jump update_aux_state_done;
84201acc:	02 6e       	jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_done;

84201ace <$M.vol_ctrl_update_aux_state.update_aux_do_not_use_data>:

update_aux_do_not_use_data:
    M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.ADVANCE_BUFFER_FIELD] = NULL;
84201ace:	e8 8e       	M[r3 + 12] = Null;

84201ad0 <$M.vol_ctrl_update_aux_state.update_aux_state_done>:
update_aux_state_done:

    // Next aux channel
    r0 = M[FP + $vol_ctrl.axfp.aux_ptr];
84201ad0:	0a d8       	r0 = M[FP + 4];

    /* Is NO_AUX */
    NULL = M[r0 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD];
84201ad2:	50 88       	Null = M[r0 + 4];
    if NZ r8 = r8 OR r6;
84201ad4:	81 fa 4a c8 	if NE r8 = r8 OR r6;
    r0 = r0 + ($volume_control_cap.vol_ctrl_aux_channel_struct.STRUC_SIZE*ADDR_PER_WORD);
84201ad8:	12 28       	r0 = r0 + 16;
    M[FP + $vol_ctrl.axfp.aux_ptr]=r0;
84201ada:	0a de       	M[FP + 4] = r0;

    r1 = M[FP + $vol_ctrl.axfp.aparm_ptr];
84201adc:	13 d8       	r1 = M[FP + 8];
    r1 = r1 + ($volume_control_cap.vol_ctrl_aux_params_struct.STRUC_SIZE*ADDR_PER_WORD);
84201ade:	1b 23       	r1 = r1 + 12;
    M[FP + $vol_ctrl.axfp.aparm_ptr]=r1;
84201ae0:	13 de       	M[FP + 8] = r1;

    r6 = r6 LSHIFT 1;
84201ae2:	00 f8 d8 d8 	r6 = r6 LSHIFT 1;
    r7 = r7 LSHIFT -1;
84201ae6:	7f f9 d9 d8 	r7 = r7 LSHIFT -1;
    if NZ jump vol_ctrl_update_aux_state_next;
84201aea:	5a 63       	if NE jump (m) $M.vol_ctrl_update_aux_state.vol_ctrl_update_aux_state_next;

    /* Save overall state */
    M[r5 + $volume_control_cap._vol_ctrl_data_struct.AUX_ACTIVE_FIELD] = r8;
84201aec:	7a f0 b8 8e 	M[r5 + 736] = r8;

    popm <FP,r0,r1,r2,r3,r4,r6,r8,rLink>;
84201af0:	57 f2 6d e0 	popm <FP, r0, r1, r2, r3, r4, r6, r8, rLink>;

84201af4 <$M.vol_ctrl_update_aux_state.update_aux_state_abort>:

update_aux_state_abort:
    popm <r5,r7>;
84201af4:	28 f0 60 e0 	popm <r5, r7>;
    rts;
84201af8:	d8 4c       	rts;

84201afa <$_vol_ctrl_compute_time_constants>:
    .CODESEGMENT PM;

    .CONST POS_ONE_Q16_N   (1<<(DAWTH-16));  // 1.0 in Q16.8 (arch4: Q16.16)

$_vol_ctrl_compute_time_constants:
    pushm <r4,r5,r6,r7,rlink>;
84201afa:	b4 1c       	pushm <r4, r5, r6, r7, rLink>;
// r0:  unsigned sample_rate
// r1:  unsigned vol_tc  (r-1)
// r2:  vol_time_constants_t *lpvcs

    r3 = r1;
84201afc:	1d 00       	r3 = r1 + Null;
    r1 = M[r2+$volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD];
84201afe:	23 88       	r1 = M[r2 + 0];

    // compute period in 100th of msec  (samples/sample_rate)*100,000
    rMAC = r1 * 3125 (int);
84201b00:	0c f0 35 f3 	rMAC = r1 * 3125 (int);
84201b04:	91 d9 
    rMAC = rMAC LSHIFT (5-DAWTH) (56bit);
84201b06:	72 f1 d1 d8 	rMAC = rMAC LSHIFT -27 (56bit);
    Div  = rMAC / r0;
84201b0a:	91 4c       	Div = rMAC / r0;
    r4 = DivResult;
84201b0c:	c6 4c       	r4 = DivResult;
    M[r2 + $volume_control_cap.vol_time_constants_struct.PERIOD_FIELD] = r4;
84201b0e:	26 8f       	M[r2 + 16] = r4;

    r4 = r4 ASHIFT (DAWTH-14);
84201b10:	09 f6 16 c9 	r4 = r4 ASHIFT 18;
    // compute volume update coeff: 11.5*n/fs (roughly 0.1dB/ms)
    r5 = r4 * 0.942071589546666;      // update coef in Q1.23 (arch4: Q1.31)
84201b14:	89 f7 cd f5 	r5 = r4 * 0.942071589641273021697998046875 (SS);
84201b18:	46 f6 d7 cc 
    // positive VOL_TC will increase the rate.
    // modified_coef ~= coef*r*(1+(r-1)*coef) (r = ramp factor)
    r1 = r3 + POS_ONE_Q16_N;
84201b1c:	04 f0 53 f0 	r1 = r3 + 65536;
84201b20:	00 20 
    if NEG r1 = 0;          // safeguard
84201b22:	04 f0 03 c0 	if NEG r1 = Null + Null;
    rMAC = r1 * r5;
84201b26:	7f f3 c1 cc 	rMAC = r1 * r5 (SS);
    r1 = rMAC ASHIFT 15;    // coef*r                in Q1.23 (arch4: Q1.31)
84201b2a:	07 f1 13 d9 	r1 = rMAC ASHIFT 15;
    rMAC = POS_ONE_Q16_N;
84201b2e:	81 f0 00 40 	rMAC = Null + 65536;
    rMAC = rMAC + r5 * r3;  // (1+(r-1)*coef)        in Q16.8 (arch4: Q16.16)
84201b32:	5f f7 c1 ca 	rMAC = rMAC + r5 * r3 (SS);
    rMAC = rMAC ASHIFT 8 (56bit);
84201b36:	c9 5d       	rMAC = rMAC ASHIFT 8 (56bit);
    rMAC = rMAC * r1;       // coef*r*(1+(r-1)*coef) in Q8.16 (arch4: Q8.24)
84201b38:	3f f1 c1 cc 	rMAC = rMAC * r1 (SS);
    r1 = rMAC ASHIFT 7;     // convert modified_coef to Q1.23 (arch4: Q1.31)
84201b3c:	8b 5d       	r1 = rMAC ASHIFT 7;
    M[r2 + $volume_control_cap.vol_time_constants_struct.VOL_TC_FIELD] = r1;
84201b3e:	63 8e       	M[r2 + 4] = r1;


   // calculate release coeff(reaches 99% in 50ms)
   r0 = r4 * 0.6553593446;
84201b40:	3e f5 d0 f2 	r0 = r4 * 0.65535934455692768096923828125 (SS);
84201b44:	a4 f6 d2 cc 
   r0 = r0 * (log(0.01)/0.05/log(2.0)/128.0/100.0)(frac);
84201b48:	ea ff d5 fb 	r0 = r0 * -0.010381025262176990509033203125 (frac);
84201b4c:	a6 f2 52 c9 
   call $math.pow2_table;
84201b50:	ff fd 94 f3 	call 0x74514;
84201b54:	24 ee 
   M[r2 + $volume_control_cap.vol_time_constants_struct.SAT_TC_FIELD] = r0;
84201b56:	a2 8e       	M[r2 + 8] = r0;

   // attack coeff, 5 times faster
   r1 = r0 * r0 (frac);
84201b58:	2f f2 43 c9 	r1 = r0 * r0 (frac);
   r1 = r1 * r1 (frac);
84201b5c:	00 f3 73 c9 	r1 = r1 * r1 (frac);
   r1 = r0 * r1 (frac);
84201b60:	3f f2 43 c9 	r1 = r0 * r1 (frac);
   M[r2 + $volume_control_cap.vol_time_constants_struct.SAT_TCP5_FIELD] = r1;
84201b64:	e3 8e       	M[r2 + 12] = r1;

   popm <r4,r5,r6,r7,rlink>;
84201b66:	b4 48       	popm <r4, r5, r6, r7, rLink>;
   rts;
84201b68:	d8 4c       	rts;
